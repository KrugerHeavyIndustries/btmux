# 1 "src/hcode/btech/mech.tech.commands.c"
# 1 "/home/murrayma/btech/btechmux-unstable//"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "src/hcode/btech/mech.tech.commands.c"
# 17 "src/hcode/btech/mech.tech.commands.c"
# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 295 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 296 "/usr/include/features.h" 2 3 4
# 318 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 319 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/math.h" 2 3 4





# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 34 "/usr/include/math.h" 2 3 4






# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4
# 65 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) ; extern double __acos (double __x) ;

extern double asin (double __x) ; extern double __asin (double __x) ;

extern double atan (double __x) ; extern double __atan (double __x) ;

extern double atan2 (double __y, double __x) ; extern double __atan2 (double __y, double __x) ;


extern double cos (double __x) ; extern double __cos (double __x) ;

extern double sin (double __x) ; extern double __sin (double __x) ;

extern double tan (double __x) ; extern double __tan (double __x) ;




extern double cosh (double __x) ; extern double __cosh (double __x) ;

extern double sinh (double __x) ; extern double __sinh (double __x) ;

extern double tanh (double __x) ; extern double __tanh (double __x) ;

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern double acosh (double __x) ; extern double __acosh (double __x) ;

extern double asinh (double __x) ; extern double __asinh (double __x) ;

extern double atanh (double __x) ; extern double __atanh (double __x) ;







extern double exp (double __x) ; extern double __exp (double __x) ;


extern double frexp (double __x, int *__exponent) ; extern double __frexp (double __x, int *__exponent) ;


extern double ldexp (double __x, int __exponent) ; extern double __ldexp (double __x, int __exponent) ;


extern double log (double __x) ; extern double __log (double __x) ;


extern double log10 (double __x) ; extern double __log10 (double __x) ;


extern double modf (double __x, double *__iptr) ; extern double __modf (double __x, double *__iptr) ;

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern double expm1 (double __x) ; extern double __expm1 (double __x) ;


extern double log1p (double __x) ; extern double __log1p (double __x) ;


extern double logb (double __x) ; extern double __logb (double __x) ;

# 152 "/usr/include/bits/mathcalls.h" 3 4


extern double pow (double __x, double __y) ; extern double __pow (double __x, double __y) ;


extern double sqrt (double __x) ; extern double __sqrt (double __x) ;





extern double hypot (double __x, double __y) ; extern double __hypot (double __x, double __y) ;






extern double cbrt (double __x) ; extern double __cbrt (double __x) ;








extern double ceil (double __x) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__const__));


extern double fmod (double __x, double __y) ; extern double __fmod (double __x, double __y) ;




extern int __isinf (double __value) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__const__));


extern double drem (double __x, double __y) ; extern double __drem (double __x, double __y) ;



extern double significand (double __x) ; extern double __significand (double __x) ;





extern double copysign (double __x, double __y) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__const__));

# 231 "/usr/include/bits/mathcalls.h" 3 4
extern int __isnan (double __value) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__const__));


extern double j0 (double) ; extern double __j0 (double) ;
extern double j1 (double) ; extern double __j1 (double) ;
extern double jn (int, double) ; extern double __jn (int, double) ;
extern double y0 (double) ; extern double __y0 (double) ;
extern double y1 (double) ; extern double __y1 (double) ;
extern double yn (int, double) ; extern double __yn (int, double) ;






extern double erf (double) ; extern double __erf (double) ;
extern double erfc (double) ; extern double __erfc (double) ;
extern double lgamma (double) ; extern double __lgamma (double) ;

# 265 "/usr/include/bits/mathcalls.h" 3 4
extern double gamma (double) ; extern double __gamma (double) ;






extern double lgamma_r (double, int *__signgamp) ; extern double __lgamma_r (double, int *__signgamp) ;







extern double rint (double __x) ; extern double __rint (double __x) ;


extern double nextafter (double __x, double __y) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__const__));





extern double remainder (double __x, double __y) ; extern double __remainder (double __x, double __y) ;



extern double scalbn (double __x, int __n) ; extern double __scalbn (double __x, int __n) ;



extern int ilogb (double __x) ; extern int __ilogb (double __x) ;
# 66 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) ; extern float __acosf (float __x) ;

extern float asinf (float __x) ; extern float __asinf (float __x) ;

extern float atanf (float __x) ; extern float __atanf (float __x) ;

extern float atan2f (float __y, float __x) ; extern float __atan2f (float __y, float __x) ;


extern float cosf (float __x) ; extern float __cosf (float __x) ;

extern float sinf (float __x) ; extern float __sinf (float __x) ;

extern float tanf (float __x) ; extern float __tanf (float __x) ;




extern float coshf (float __x) ; extern float __coshf (float __x) ;

extern float sinhf (float __x) ; extern float __sinhf (float __x) ;

extern float tanhf (float __x) ; extern float __tanhf (float __x) ;

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern float acoshf (float __x) ; extern float __acoshf (float __x) ;

extern float asinhf (float __x) ; extern float __asinhf (float __x) ;

extern float atanhf (float __x) ; extern float __atanhf (float __x) ;







extern float expf (float __x) ; extern float __expf (float __x) ;


extern float frexpf (float __x, int *__exponent) ; extern float __frexpf (float __x, int *__exponent) ;


extern float ldexpf (float __x, int __exponent) ; extern float __ldexpf (float __x, int __exponent) ;


extern float logf (float __x) ; extern float __logf (float __x) ;


extern float log10f (float __x) ; extern float __log10f (float __x) ;


extern float modff (float __x, float *__iptr) ; extern float __modff (float __x, float *__iptr) ;

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern float expm1f (float __x) ; extern float __expm1f (float __x) ;


extern float log1pf (float __x) ; extern float __log1pf (float __x) ;


extern float logbf (float __x) ; extern float __logbf (float __x) ;

# 152 "/usr/include/bits/mathcalls.h" 3 4


extern float powf (float __x, float __y) ; extern float __powf (float __x, float __y) ;


extern float sqrtf (float __x) ; extern float __sqrtf (float __x) ;





extern float hypotf (float __x, float __y) ; extern float __hypotf (float __x, float __y) ;






extern float cbrtf (float __x) ; extern float __cbrtf (float __x) ;








extern float ceilf (float __x) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) ; extern float __fmodf (float __x, float __y) ;




extern int __isinff (float __value) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__const__));


extern float dremf (float __x, float __y) ; extern float __dremf (float __x, float __y) ;



extern float significandf (float __x) ; extern float __significandf (float __x) ;





extern float copysignf (float __x, float __y) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__const__));

# 231 "/usr/include/bits/mathcalls.h" 3 4
extern int __isnanf (float __value) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__const__));


extern float j0f (float) ; extern float __j0f (float) ;
extern float j1f (float) ; extern float __j1f (float) ;
extern float jnf (int, float) ; extern float __jnf (int, float) ;
extern float y0f (float) ; extern float __y0f (float) ;
extern float y1f (float) ; extern float __y1f (float) ;
extern float ynf (int, float) ; extern float __ynf (int, float) ;






extern float erff (float) ; extern float __erff (float) ;
extern float erfcf (float) ; extern float __erfcf (float) ;
extern float lgammaf (float) ; extern float __lgammaf (float) ;

# 265 "/usr/include/bits/mathcalls.h" 3 4
extern float gammaf (float) ; extern float __gammaf (float) ;






extern float lgammaf_r (float, int *__signgamp) ; extern float __lgammaf_r (float, int *__signgamp) ;







extern float rintf (float __x) ; extern float __rintf (float __x) ;


extern float nextafterf (float __x, float __y) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__const__));





extern float remainderf (float __x, float __y) ; extern float __remainderf (float __x, float __y) ;



extern float scalbnf (float __x, int __n) ; extern float __scalbnf (float __x, int __n) ;



extern int ilogbf (float __x) ; extern int __ilogbf (float __x) ;
# 89 "/usr/include/math.h" 2 3 4
# 109 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) ; extern long double __acosl (long double __x) ;

extern long double asinl (long double __x) ; extern long double __asinl (long double __x) ;

extern long double atanl (long double __x) ; extern long double __atanl (long double __x) ;

extern long double atan2l (long double __y, long double __x) ; extern long double __atan2l (long double __y, long double __x) ;


extern long double cosl (long double __x) ; extern long double __cosl (long double __x) ;

extern long double sinl (long double __x) ; extern long double __sinl (long double __x) ;

extern long double tanl (long double __x) ; extern long double __tanl (long double __x) ;




extern long double coshl (long double __x) ; extern long double __coshl (long double __x) ;

extern long double sinhl (long double __x) ; extern long double __sinhl (long double __x) ;

extern long double tanhl (long double __x) ; extern long double __tanhl (long double __x) ;

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern long double acoshl (long double __x) ; extern long double __acoshl (long double __x) ;

extern long double asinhl (long double __x) ; extern long double __asinhl (long double __x) ;

extern long double atanhl (long double __x) ; extern long double __atanhl (long double __x) ;







extern long double expl (long double __x) ; extern long double __expl (long double __x) ;


extern long double frexpl (long double __x, int *__exponent) ; extern long double __frexpl (long double __x, int *__exponent) ;


extern long double ldexpl (long double __x, int __exponent) ; extern long double __ldexpl (long double __x, int __exponent) ;


extern long double logl (long double __x) ; extern long double __logl (long double __x) ;


extern long double log10l (long double __x) ; extern long double __log10l (long double __x) ;


extern long double modfl (long double __x, long double *__iptr) ; extern long double __modfl (long double __x, long double *__iptr) ;

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern long double expm1l (long double __x) ; extern long double __expm1l (long double __x) ;


extern long double log1pl (long double __x) ; extern long double __log1pl (long double __x) ;


extern long double logbl (long double __x) ; extern long double __logbl (long double __x) ;

# 152 "/usr/include/bits/mathcalls.h" 3 4


extern long double powl (long double __x, long double __y) ; extern long double __powl (long double __x, long double __y) ;


extern long double sqrtl (long double __x) ; extern long double __sqrtl (long double __x) ;





extern long double hypotl (long double __x, long double __y) ; extern long double __hypotl (long double __x, long double __y) ;






extern long double cbrtl (long double __x) ; extern long double __cbrtl (long double __x) ;








extern long double ceill (long double __x) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) ; extern long double __fmodl (long double __x, long double __y) ;




extern int __isinfl (long double __value) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) ; extern long double __dreml (long double __x, long double __y) ;



extern long double significandl (long double __x) ; extern long double __significandl (long double __x) ;





extern long double copysignl (long double __x, long double __y) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__const__));

# 231 "/usr/include/bits/mathcalls.h" 3 4
extern int __isnanl (long double __value) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__const__));


extern long double j0l (long double) ; extern long double __j0l (long double) ;
extern long double j1l (long double) ; extern long double __j1l (long double) ;
extern long double jnl (int, long double) ; extern long double __jnl (int, long double) ;
extern long double y0l (long double) ; extern long double __y0l (long double) ;
extern long double y1l (long double) ; extern long double __y1l (long double) ;
extern long double ynl (int, long double) ; extern long double __ynl (int, long double) ;






extern long double erfl (long double) ; extern long double __erfl (long double) ;
extern long double erfcl (long double) ; extern long double __erfcl (long double) ;
extern long double lgammal (long double) ; extern long double __lgammal (long double) ;

# 265 "/usr/include/bits/mathcalls.h" 3 4
extern long double gammal (long double) ; extern long double __gammal (long double) ;






extern long double lgammal_r (long double, int *__signgamp) ; extern long double __lgammal_r (long double, int *__signgamp) ;







extern long double rintl (long double __x) ; extern long double __rintl (long double __x) ;


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__const__));





extern long double remainderl (long double __x, long double __y) ; extern long double __remainderl (long double __x, long double __y) ;



extern long double scalbnl (long double __x, int __n) ; extern long double __scalbnl (long double __x, int __n) ;



extern int ilogbl (long double __x) ; extern int __ilogbl (long double __x) ;
# 110 "/usr/include/math.h" 2 3 4
# 125 "/usr/include/math.h" 3 4
extern int signgam;
# 252 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 277 "/usr/include/math.h" 3 4
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);
# 362 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathinline.h" 1 3 4
# 291 "/usr/include/bits/mathinline.h" 3 4
extern __inline double __sgn (double) ; extern __inline double __sgn (double __x) { return __x == 0.0 ? 0.0 : (__x > 0.0 ? 1.0 : -1.0); } extern __inline float __sgnf (float) ; extern __inline float __sgnf (float __x) { return __x == 0.0 ? 0.0 : (__x > 0.0 ? 1.0 : -1.0); } extern __inline long double __sgnl (long double) ; extern __inline long double __sgnl (long double __x) { return __x == 0.0 ? 0.0 : (__x > 0.0 ? 1.0 : -1.0); }
# 425 "/usr/include/bits/mathinline.h" 3 4
extern __inline double atan2 (double __y, double __x) { register long double __value; __asm __volatile__ ("fpatan" : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)"); return __value; } extern __inline float atan2f (float __y, float __x) { register long double __value; __asm __volatile__ ("fpatan" : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)"); return __value; } extern __inline long double atan2l (long double __y, long double __x) { register long double __value; __asm __volatile__ ("fpatan" : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)"); return __value; }
extern __inline long double __atan2l (long double __y, long double __x) { register long double __value; __asm __volatile__ ("fpatan" : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)"); return __value; }


extern __inline double fmod (double __x, double __y) { register long double __value; __asm __volatile__ ("1:	fprem\n\t" "fnstsw	%%ax\n\t" "sahf\n\t" "jp	1b" : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc"); return __value; } extern __inline float fmodf (float __x, float __y) { register long double __value; __asm __volatile__ ("1:	fprem\n\t" "fnstsw	%%ax\n\t" "sahf\n\t" "jp	1b" : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc"); return __value; } extern __inline long double fmodl (long double __x, long double __y) { register long double __value; __asm __volatile__ ("1:	fprem\n\t" "fnstsw	%%ax\n\t" "sahf\n\t" "jp	1b" : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc"); return __value; }
# 446 "/usr/include/bits/mathinline.h" 3 4
extern __inline double fabs (double __x) { return __builtin_fabs (__x); }
extern __inline float fabsf (float __x) { return __builtin_fabsf (__x); }
extern __inline long double fabsl (long double __x) { return __builtin_fabsl (__x); }
extern __inline long double __fabsl (long double __x) { return __builtin_fabsl (__x); }
# 468 "/usr/include/bits/mathinline.h" 3 4
extern __inline double atan (double __x) { register double __result; __asm __volatile__ ("fld1; fpatan" : "=t" (__result) : "0" (__x) : "st(1)"); return __result; } extern __inline float atanf (float __x) { register float __result; __asm __volatile__ ("fld1; fpatan" : "=t" (__result) : "0" (__x) : "st(1)"); return __result; } extern __inline long double atanl (long double __x) { register long double __result; __asm __volatile__ ("fld1; fpatan" : "=t" (__result) : "0" (__x) : "st(1)"); return __result; }

extern __inline long double __sgn1l (long double) ; extern __inline long double __sgn1l (long double __x) { __extension__ union { long double __xld; unsigned int __xi[3]; } __n = { __xld: __x }; __n.__xi[2] = (__n.__xi[2] & 0x8000) | 0x3fff; __n.__xi[1] = 0x80000000; __n.__xi[0] = 0; return __n.__xld; }
# 494 "/usr/include/bits/mathinline.h" 3 4
extern __inline double floor (double __x) { register long double __value; __volatile unsigned short int __cw; __volatile unsigned short int __cwtmp; __asm __volatile ("fnstcw %0" : "=m" (__cw)); __cwtmp = (__cw & 0xf3ff) | 0x0400; __asm __volatile ("fldcw %0" : : "m" (__cwtmp)); __asm __volatile ("frndint" : "=t" (__value) : "0" (__x)); __asm __volatile ("fldcw %0" : : "m" (__cw)); return __value; } extern __inline float floorf (float __x) { register long double __value; __volatile unsigned short int __cw; __volatile unsigned short int __cwtmp; __asm __volatile ("fnstcw %0" : "=m" (__cw)); __cwtmp = (__cw & 0xf3ff) | 0x0400; __asm __volatile ("fldcw %0" : : "m" (__cwtmp)); __asm __volatile ("frndint" : "=t" (__value) : "0" (__x)); __asm __volatile ("fldcw %0" : : "m" (__cw)); return __value; } extern __inline long double floorl (long double __x) { register long double __value; __volatile unsigned short int __cw; __volatile unsigned short int __cwtmp; __asm __volatile ("fnstcw %0" : "=m" (__cw)); __cwtmp = (__cw & 0xf3ff) | 0x0400; __asm __volatile ("fldcw %0" : : "m" (__cwtmp)); __asm __volatile ("frndint" : "=t" (__value) : "0" (__x)); __asm __volatile ("fldcw %0" : : "m" (__cw)); return __value; }
# 505 "/usr/include/bits/mathinline.h" 3 4
extern __inline double ceil (double __x) { register long double __value; __volatile unsigned short int __cw; __volatile unsigned short int __cwtmp; __asm __volatile ("fnstcw %0" : "=m" (__cw)); __cwtmp = (__cw & 0xf3ff) | 0x0800; __asm __volatile ("fldcw %0" : : "m" (__cwtmp)); __asm __volatile ("frndint" : "=t" (__value) : "0" (__x)); __asm __volatile ("fldcw %0" : : "m" (__cw)); return __value; } extern __inline float ceilf (float __x) { register long double __value; __volatile unsigned short int __cw; __volatile unsigned short int __cwtmp; __asm __volatile ("fnstcw %0" : "=m" (__cw)); __cwtmp = (__cw & 0xf3ff) | 0x0800; __asm __volatile ("fldcw %0" : : "m" (__cwtmp)); __asm __volatile ("frndint" : "=t" (__value) : "0" (__x)); __asm __volatile ("fldcw %0" : : "m" (__cw)); return __value; } extern __inline long double ceill (long double __x) { register long double __value; __volatile unsigned short int __cw; __volatile unsigned short int __cwtmp; __asm __volatile ("fnstcw %0" : "=m" (__cw)); __cwtmp = (__cw & 0xf3ff) | 0x0800; __asm __volatile ("fldcw %0" : : "m" (__cwtmp)); __asm __volatile ("frndint" : "=t" (__value) : "0" (__x)); __asm __volatile ("fldcw %0" : : "m" (__cw)); return __value; }
# 654 "/usr/include/bits/mathinline.h" 3 4
extern __inline double drem (double __x, double __y) { register double __value; register int __clobbered; __asm __volatile__ ("1:	fprem1\n\t" "fstsw	%%ax\n\t" "sahf\n\t" "jp	1b" : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc"); return __value; } extern __inline float dremf (float __x, float __y) { register double __value; register int __clobbered; __asm __volatile__ ("1:	fprem1\n\t" "fstsw	%%ax\n\t" "sahf\n\t" "jp	1b" : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc"); return __value; } extern __inline long double dreml (long double __x, long double __y) { register double __value; register int __clobbered; __asm __volatile__ ("1:	fprem1\n\t" "fstsw	%%ax\n\t" "sahf\n\t" "jp	1b" : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc"); return __value; }
# 667 "/usr/include/bits/mathinline.h" 3 4
extern __inline int
__finite (double __x)
{
  return (__extension__
   (((((union { double __d; int __i[2]; }) {__d: __x}).__i[1]
      | 0x800fffffu) + 1) >> 31));
}
# 363 "/usr/include/math.h" 2 3 4
# 423 "/usr/include/math.h" 3 4

# 18 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 214 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 3 4
typedef unsigned int size_t;
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n) ;


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     ;






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     ;





extern void *memset (void *__s, int __c, size_t __n) ;


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__pure__));


extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__pure__));

# 80 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     ;

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n) ;


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     ;

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) ;


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__pure__));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__pure__));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__pure__));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n) ;

# 126 "/usr/include/string.h" 3 4
extern char *strdup (__const char *__s) __attribute__ ((__malloc__));
# 160 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c) __attribute__ ((__pure__));

extern char *strrchr (__const char *__s, int __c) __attribute__ ((__pure__));











extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__pure__));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__pure__));

extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__pure__));

extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__pure__));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     ;




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr) ;

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr) ;
# 228 "/usr/include/string.h" 3 4


extern size_t strlen (__const char *__s) __attribute__ ((__pure__));

# 241 "/usr/include/string.h" 3 4


extern char *strerror (int __errnum) ;




extern char *strerror_r (int __errnum, char *__buf, size_t __buflen) ;




extern void __bzero (void *__s, size_t __n) ;



extern void bcopy (__const void *__src, void *__dest, size_t __n) ;


extern void bzero (void *__s, size_t __n) ;


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__pure__));


extern char *index (__const char *__s, int __c) __attribute__ ((__pure__));


extern char *rindex (__const char *__s, int __c) __attribute__ ((__pure__));



extern int ffs (int __i) __attribute__ ((__const__));
# 287 "/usr/include/string.h" 3 4
extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__pure__));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__pure__));
# 309 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim) ;
# 372 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/string.h" 1 3 4
# 373 "/usr/include/string.h" 2 3 4


# 1 "/usr/include/bits/string2.h" 1 3 4
# 52 "/usr/include/bits/string2.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 53 "/usr/include/bits/string2.h" 2 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 129 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 130 "/usr/include/bits/types.h" 2 3 4






__extension__ typedef unsigned long long int __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef unsigned long long int __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef long long int __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef unsigned long long int __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef int __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef long long int __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef unsigned long long int __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef unsigned long long int __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 54 "/usr/include/bits/string2.h" 2 3 4
# 389 "/usr/include/bits/string2.h" 3 4
extern void *__rawmemchr (const void *__s, int __c);
# 919 "/usr/include/bits/string2.h" 3 4
extern __inline size_t __strcspn_c1 (__const char *__s, int __reject);
extern __inline size_t
__strcspn_c1 (__const char *__s, int __reject)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c2 (__const char *__s, int __reject1,
         int __reject2);
extern __inline size_t
__strcspn_c2 (__const char *__s, int __reject1, int __reject2)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c3 (__const char *__s, int __reject1,
         int __reject2, int __reject3);
extern __inline size_t
__strcspn_c3 (__const char *__s, int __reject1, int __reject2,
       int __reject3)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}
# 976 "/usr/include/bits/string2.h" 3 4
extern __inline size_t __strspn_c1 (__const char *__s, int __accept);
extern __inline size_t
__strspn_c1 (__const char *__s, int __accept)
{
  register size_t __result = 0;

  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c2 (__const char *__s, int __accept1,
        int __accept2);
extern __inline size_t
__strspn_c2 (__const char *__s, int __accept1, int __accept2)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c3 (__const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline size_t
__strspn_c3 (__const char *__s, int __accept1, int __accept2, int __accept3)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2
  || __s[__result] == __accept3)
    ++__result;
  return __result;
}
# 1033 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strpbrk_c2 (__const char *__s, int __accept1,
         int __accept2);
extern __inline char *
__strpbrk_c2 (__const char *__s, int __accept1, int __accept2)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}

extern __inline char *__strpbrk_c3 (__const char *__s, int __accept1,
         int __accept2, int __accept3);
extern __inline char *
__strpbrk_c3 (__const char *__s, int __accept1, int __accept2,
       int __accept3)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
  && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}
# 1085 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void *)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void *)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
      *__nextp = __s;
    }
  return __result;
}
# 1117 "/usr/include/bits/string2.h" 3 4
extern char *__strsep_g (char **__stringp, __const char *__delim);
# 1135 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strsep_1c (char **__s, char __reject);
extern __inline char *
__strsep_1c (char **__s, char __reject)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : strchr (__retval, __reject)))) != ((void *)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}
# 1211 "/usr/include/bits/string2.h" 3 4
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4


# 554 "/usr/include/stdlib.h" 3 4


extern void *malloc (size_t __size) __attribute__ ((__malloc__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__malloc__));

# 922 "/usr/include/stdlib.h" 3 4

# 1212 "/usr/include/bits/string2.h" 2 3 4




extern char *__strdup (__const char *__string) __attribute__ ((__malloc__));
# 1235 "/usr/include/bits/string2.h" 3 4
extern char *__strndup (__const char *__string, size_t __n)
     __attribute__ ((__malloc__));
# 376 "/usr/include/string.h" 2 3 4




# 19 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "src/hcode/btech/mech.h" 1
# 18 "src/hcode/btech/mech.h"
# 1 "src/autoconf.h" 1







# 1 "src/copyright.h" 1
# 9 "src/autoconf.h" 2
# 343 "src/autoconf.h"
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stdarg.h" 1 3 4
# 43 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 105 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 344 "src/autoconf.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 326 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 3 4
typedef int wchar_t;
# 34 "/usr/include/stdlib.h" 2 3 4


# 93 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;



# 137 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) ;




extern double atof (__const char *__nptr) __attribute__ ((__pure__));

extern int atoi (__const char *__nptr) __attribute__ ((__pure__));

extern long int atol (__const char *__nptr) __attribute__ ((__pure__));





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__pure__));





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr) ;

# 174 "/usr/include/stdlib.h" 3 4


extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     ;

# 264 "/usr/include/stdlib.h" 3 4
extern double __strtod_internal (__const char *__restrict __nptr,
     char **__restrict __endptr, int __group)
     ;
extern float __strtof_internal (__const char *__restrict __nptr,
    char **__restrict __endptr, int __group)
     ;
extern long double __strtold_internal (__const char *__restrict __nptr,
           char **__restrict __endptr,
           int __group) ;

extern long int __strtol_internal (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group) ;



extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
          char **__restrict __endptr,
          int __base, int __group) ;




__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
      char **__restrict __endptr,
      int __base, int __group) ;



__extension__
extern unsigned long long int __strtoull_internal (__const char *
         __restrict __nptr,
         char **__restrict __endptr,
         int __base, int __group)
     ;








extern __inline double
strtod (__const char *__restrict __nptr, char **__restrict __endptr)
{
  return __strtod_internal (__nptr, __endptr, 0);
}
extern __inline long int
strtol (__const char *__restrict __nptr, char **__restrict __endptr,
 int __base)
{
  return __strtol_internal (__nptr, __endptr, __base, 0);
}
extern __inline unsigned long int
strtoul (__const char *__restrict __nptr, char **__restrict __endptr,
  int __base)
{
  return __strtoul_internal (__nptr, __endptr, __base, 0);
}

# 343 "/usr/include/stdlib.h" 3 4
__extension__ extern __inline long long int
strtoq (__const char *__restrict __nptr, char **__restrict __endptr,
 int __base)
{
  return __strtoll_internal (__nptr, __endptr, __base, 0);
}
__extension__ extern __inline unsigned long long int
strtouq (__const char *__restrict __nptr, char **__restrict __endptr,
  int __base)
{
  return __strtoull_internal (__nptr, __endptr, __base, 0);
}




__extension__ extern __inline long long int
strtoll (__const char *__restrict __nptr, char **__restrict __endptr,
  int __base)
{
  return __strtoll_internal (__nptr, __endptr, __base, 0);
}
__extension__ extern __inline unsigned long long int
strtoull (__const char * __restrict __nptr, char **__restrict __endptr,
   int __base)
{
  return __strtoull_internal (__nptr, __endptr, __base, 0);
}




extern __inline double
atof (__const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
extern __inline int
atoi (__const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline long int
atol (__const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}




__extension__ extern __inline long long int
atoll (__const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}

# 408 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) ;


extern long int a64l (__const char *__s) __attribute__ ((__pure__));




# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 62 "/usr/include/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 100 "/usr/include/sys/types.h" 3 4
typedef __pid_t pid_t;




typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/sys/types.h" 2 3 4
# 147 "/usr/include/sys/types.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 191 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 118 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4

# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 128 "/usr/include/sys/select.h" 3 4

# 217 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 220 "/usr/include/sys/types.h" 2 3 4
# 231 "/usr/include/sys/types.h" 3 4
typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 266 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 83 "/usr/include/bits/sched.h" 3 4
struct __sched_param
  {
    int __sched_priority;
  };
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4

typedef int __atomic_lock_t;


struct _pthread_fastlock
{
  long int __status;
  __atomic_lock_t __spinlock;

};



typedef struct _pthread_descr_struct *_pthread_descr;





typedef struct __pthread_attr_s
{
  int __detachstate;
  int __schedpolicy;
  struct __sched_param __schedparam;
  int __inheritsched;
  int __scope;
  size_t __guardsize;
  int __stackaddr_set;
  void *__stackaddr;
  size_t __stacksize;
} pthread_attr_t;





__extension__ typedef long long __pthread_cond_align_t;




typedef struct
{
  struct _pthread_fastlock __c_lock;
  _pthread_descr __c_waiting;
  char __padding[48 - sizeof (struct _pthread_fastlock)
   - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
  __pthread_cond_align_t __align;
} pthread_cond_t;



typedef struct
{
  int __dummy;
} pthread_condattr_t;


typedef unsigned int pthread_key_t;





typedef struct
{
  int __m_reserved;
  int __m_count;
  _pthread_descr __m_owner;
  int __m_kind;
  struct _pthread_fastlock __m_lock;
} pthread_mutex_t;



typedef struct
{
  int __mutexkind;
} pthread_mutexattr_t;



typedef int pthread_once_t;
# 152 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;
# 267 "/usr/include/sys/types.h" 2 3 4



# 417 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) ;


extern void srandom (unsigned int __seed) ;





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) ;



extern char *setstate (char *__statebuf) ;







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) ;

extern int srandom_r (unsigned int __seed, struct random_data *__buf) ;

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf) ;

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf) ;






extern int rand (void) ;

extern void srand (unsigned int __seed) ;




extern int rand_r (unsigned int *__seed) ;







extern double drand48 (void) ;
extern double erand48 (unsigned short int __xsubi[3]) ;


extern long int lrand48 (void) ;
extern long int nrand48 (unsigned short int __xsubi[3]) ;


extern long int mrand48 (void) ;
extern long int jrand48 (unsigned short int __xsubi[3]) ;


extern void srand48 (long int __seedval) ;
extern unsigned short int *seed48 (unsigned short int __seed16v[3]) ;
extern void lcong48 (unsigned short int __param[7]) ;





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) ;
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) ;


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result) ;
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result) ;


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result) ;
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result) ;


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     ;

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) ;

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer) ;
# 564 "/usr/include/stdlib.h" 3 4



extern void *realloc (void *__ptr, size_t __size) __attribute__ ((__malloc__));

extern void free (void *__ptr) ;




extern void cfree (void *__ptr) ;



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) ;






# 579 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) __attribute__ ((__malloc__));
# 592 "/usr/include/stdlib.h" 3 4


extern void abort (void) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) ;





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     ;






extern void exit (int __status) __attribute__ ((__noreturn__));

# 624 "/usr/include/stdlib.h" 3 4


extern char *getenv (__const char *__name) ;




extern char *__secure_getenv (__const char *__name) ;





extern int putenv (char *__string) ;





extern int setenv (__const char *__name, __const char *__value, int __replace)
     ;


extern int unsetenv (__const char *__name) ;






extern int clearenv (void) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template);
# 693 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) ;








extern int system (__const char *__command);

# 720 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);









extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar);



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar);



extern int abs (int __x) __attribute__ ((__const__));
extern long int labs (long int __x) __attribute__ ((__const__));












extern div_t div (int __numer, int __denom)
     __attribute__ ((__const__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__const__));

# 784 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) ;




extern char *gcvt (double __value, int __ndigit, char *__buf) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) ;
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) ;

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len) ;
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len) ;







extern int mblen (__const char *__s, size_t __n) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) ;


extern int wctomb (char *__s, wchar_t __wchar) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) ;

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     ;








extern int rpmatch (__const char *__response) ;
# 916 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem) ;






# 345 "src/autoconf.h" 2
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 1 3 4
# 11 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 1 3 4
# 122 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 130 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 36 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 37 "/usr/include/bits/local_lim.h" 2 3 4
# 131 "/usr/include/bits/posix1_lim.h" 2 3 4
# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 149 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 2 3 4
# 346 "src/autoconf.h" 2
# 368 "src/autoconf.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4

# 171 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 172 "/usr/include/unistd.h" 2 3 4
# 195 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 196 "/usr/include/unistd.h" 2 3 4
# 236 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 256 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) ;
# 286 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) ;
# 305 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes);





extern ssize_t write (int __fd, __const void *__buf, size_t __n);
# 369 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) ;
# 378 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) ;
# 390 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     ;






extern int usleep (__useconds_t __useconds);
# 414 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     ;




extern int chdir (__const char *__path) ;



extern int fchdir (int __fd) ;
# 448 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) ;
# 461 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf) ;




extern int dup (int __fd) ;


extern int dup2 (int __fd, int __fd2) ;


extern char **__environ;







extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) ;
# 492 "/usr/include/unistd.h" 3 4
extern int execv (__const char *__path, char *__const __argv[]) ;



extern int execle (__const char *__path, __const char *__arg, ...) ;



extern int execl (__const char *__path, __const char *__arg, ...) ;



extern int execvp (__const char *__file, char *__const __argv[]) ;




extern int execlp (__const char *__file, __const char *__arg, ...) ;




extern int nice (int __inc) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 25 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,


    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
# 526 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name) ;


extern long int fpathconf (int __fd, int __name) ;


extern long int sysconf (int __name) __attribute__ ((__const__));



extern size_t confstr (int __name, char *__buf, size_t __len) ;




extern __pid_t getpid (void) ;


extern __pid_t getppid (void) ;




extern __pid_t getpgrp (void) ;
# 561 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) ;
# 570 "/usr/include/unistd.h" 3 4
extern int setpgid (__pid_t __pid, __pid_t __pgid) ;
# 587 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) ;
# 605 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) ;







extern __uid_t getuid (void) ;


extern __uid_t geteuid (void) ;


extern __gid_t getgid (void) ;


extern __gid_t getegid (void) ;




extern int getgroups (int __size, __gid_t __list[]) ;
# 638 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) ;




extern int seteuid (__uid_t __uid) ;






extern int setgid (__gid_t __gid) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) ;




extern int setegid (__gid_t __gid) ;
# 690 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) ;






extern __pid_t vfork (void) ;





extern char *ttyname (int __fd) ;



extern int ttyname_r (int __fd, char *__buf, size_t __buflen) ;



extern int isatty (int __fd) ;





extern int ttyslot (void) ;




extern int link (__const char *__from, __const char *__to) ;



extern int symlink (__const char *__from, __const char *__to) ;




extern int readlink (__const char *__restrict __path, char *__restrict __buf,
       size_t __len) ;



extern int unlink (__const char *__name) ;


extern int rmdir (__const char *__path) ;



extern __pid_t tcgetpgrp (int __fd) ;


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) ;






extern char *getlogin (void);
# 766 "/usr/include/unistd.h" 3 4
extern int setlogin (__const char *__name) ;
# 775 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 55 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 69 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 153 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       ;
# 776 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) ;






extern int sethostname (__const char *__name, size_t __len) ;



extern int sethostid (long int __id) ;





extern int getdomainname (char *__name, size_t __len) ;
extern int setdomainname (__const char *__name, size_t __len) ;





extern int vhangup (void) ;


extern int revoke (__const char *__file) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale) ;





extern int acct (__const char *__name) ;



extern char *getusershell (void) ;
extern void endusershell (void) ;
extern void setusershell (void) ;





extern int daemon (int __nochdir, int __noclose) ;






extern int chroot (__const char *__path) ;



extern char *getpass (__const char *__prompt);
# 857 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) ;




extern int getpagesize (void) __attribute__ ((__const__));




extern int truncate (__const char *__file, __off_t __length) ;
# 893 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) ;
# 909 "/usr/include/unistd.h" 3 4
extern int getdtablesize (void) ;
# 918 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) ;





extern void *sbrk (intptr_t __delta) ;
# 939 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) ;
# 962 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len);
# 993 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes) ;
# 1024 "/usr/include/unistd.h" 3 4

# 369 "src/autoconf.h" 2







# 1 "/usr/include/sys/time.h" 1 3 4
# 26 "/usr/include/sys/time.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 27 "/usr/include/sys/time.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 29 "/usr/include/sys/time.h" 2 3 4
# 38 "/usr/include/sys/time.h" 3 4

# 56 "/usr/include/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 72 "/usr/include/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) ;




extern int settimeofday (__const struct timeval *__tv,
    __const struct timezone *__tz) ;





extern int adjtime (__const struct timeval *__delta,
      struct timeval *__olddelta) ;




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) ;




extern int setitimer (__itimer_which_t __which,
        __const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) ;




extern int utimes (__const char *__file, __const struct timeval __tvp[2])
     ;



extern int lutimes (__const char *__file, __const struct timeval __tvp[2])
     ;


extern int futimes (int __fd, __const struct timeval __tvp[2]) ;
# 181 "/usr/include/sys/time.h" 3 4

# 377 "src/autoconf.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 40 "/usr/include/bits/time.h" 3 4
extern long int __sysconf (int);
# 43 "/usr/include/time.h" 2 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 129 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 178 "/usr/include/time.h" 3 4



extern clock_t clock (void) ;


extern time_t time (time_t *__timer) ;


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) ;





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) ;

# 226 "/usr/include/time.h" 3 4



extern struct tm *gmtime (__const time_t *__timer) ;



extern struct tm *localtime (__const time_t *__timer) ;





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) ;



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) ;





extern char *asctime (__const struct tm *__tp) ;


extern char *ctime (__const time_t *__timer) ;







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) ;


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) ;




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) ;



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) ;
# 309 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) ;


extern time_t timelocal (struct tm *__tp) ;


extern int dysize (int __year) __attribute__ ((__const__));
# 324 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) ;


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) ;


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     ;
# 353 "/usr/include/time.h" 3 4
extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) ;


extern int timer_delete (timer_t __timerid) ;


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) ;


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     ;


extern int timer_getoverrun (timer_t __timerid) ;
# 413 "/usr/include/time.h" 3 4

# 378 "src/autoconf.h" 2
# 390 "src/autoconf.h"
# 1 "/usr/include/sys/param.h" 1 3 4
# 22 "/usr/include/sys/param.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 1 3 4
# 23 "/usr/include/sys/param.h" 2 3 4

# 1 "/usr/include/linux/param.h" 1 3 4



# 1 "/usr/include/asm/param.h" 1 3 4
# 5 "/usr/include/linux/param.h" 2 3 4
# 25 "/usr/include/sys/param.h" 2 3 4
# 391 "src/autoconf.h" 2

# 1 "src/getpagesize.h" 1
# 393 "src/autoconf.h" 2
# 402 "src/autoconf.h"
extern int errno;
extern void perror (const char *);






extern time_t timelocal (struct tm *);







extern int tolower (int);


extern int toupper (int);
# 430 "src/autoconf.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4


typedef struct _IO_FILE FILE;





# 62 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 72 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 14 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 355 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 15 "/usr/include/_G_config.h" 2 3 4
# 24 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 51 "/usr/include/wchar.h" 2 3 4
# 76 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 25 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 44 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/gconv.h" 1 3 4
# 28 "/usr/include/gconv.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 29 "/usr/include/gconv.h" 2 3 4


# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 32 "/usr/include/gconv.h" 2 3 4





enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
       __const unsigned char **, __const unsigned char *,
       unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
      struct __gconv_step_data *, void *,
      __const unsigned char *,
      __const unsigned char **,
      __const unsigned char *, unsigned char **,
      size_t *);


typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
       __const unsigned char *,
       unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
     size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [];
} *__gconv_t;
# 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 163 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 173 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 196 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 264 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 312 "/usr/include/libio.h" 3 4
  __off64_t _offset;





  void *__pad1;
  void *__pad2;

  int _mode;

  char _unused2[15 * sizeof (int) - 2 * sizeof (void *)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 351 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 403 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *) ;
extern int __uflow (_IO_FILE *) ;
extern int __overflow (_IO_FILE *, int) ;
extern wint_t __wunderflow (_IO_FILE *) ;
extern wint_t __wuflow (_IO_FILE *) ;
extern wint_t __woverflow (_IO_FILE *, wint_t) ;
# 433 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp) ;
extern int _IO_putc (int __c, _IO_FILE *__fp) ;
extern int _IO_feof (_IO_FILE *__fp) ;
extern int _IO_ferror (_IO_FILE *__fp) ;

extern int _IO_peekc_locked (_IO_FILE *__fp) ;





extern void _IO_flockfile (_IO_FILE *) ;
extern void _IO_funlockfile (_IO_FILE *) ;
extern int _IO_ftrylockfile (_IO_FILE *) ;
# 463 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict) ;
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list) ;
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t) ;
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t) ;

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int) ;
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int) ;

extern void _IO_free_backup_area (_IO_FILE *) ;
# 73 "/usr/include/stdio.h" 2 3 4
# 86 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




# 138 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) ;

extern int rename (__const char *__old, __const char *__new) ;









extern FILE *tmpfile (void);
# 178 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) ;





extern char *tmpnam_r (char *__s) ;
# 196 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__malloc__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 221 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 235 "/usr/include/stdio.h" 3 4






extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes);




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream);
# 262 "/usr/include/stdio.h" 3 4

# 273 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, __const char *__modes) ;
# 294 "/usr/include/stdio.h" 3 4



extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) ;



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) ;





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) ;


extern void setlinebuf (FILE *__stream) ;








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) ;





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) ;





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));

# 388 "/usr/include/stdio.h" 3 4





extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...);




extern int scanf (__const char *__restrict __format, ...);

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) ;

# 430 "/usr/include/stdio.h" 3 4





extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 454 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 465 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 498 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream);






extern char *gets (char *__s);

# 578 "/usr/include/stdio.h" 3 4





extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream);




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 631 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream);
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream);




extern void rewind (FILE *__stream);

# 686 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 709 "/usr/include/stdio.h" 3 4

# 718 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) ;

extern int feof (FILE *__stream) ;

extern int ferror (FILE *__stream) ;




extern void clearerr_unlocked (FILE *__stream) ;
extern int feof_unlocked (FILE *__stream) ;
extern int ferror_unlocked (FILE *__stream) ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];
# 748 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) ;




extern int fileno_unlocked (FILE *__stream) ;
# 767 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes);





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) ;
# 807 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) ;



extern int ftrylockfile (FILE *__stream) ;


extern void funlockfile (FILE *__stream) ;
# 828 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 33 "/usr/include/bits/stdio.h" 3 4
extern __inline int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}


extern __inline int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline int
getc_unlocked (FILE *__fp)
{
  return ((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline int
getchar_unlocked (void)
{
  return ((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline int
fputc_unlocked (int __c, FILE *__stream)
{
  return (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline int
putc_unlocked (int __c, FILE *__stream)
{
  return (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline int
putchar_unlocked (int __c)
{
  return (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 111 "/usr/include/bits/stdio.h" 3 4
extern __inline int
feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline int
ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 829 "/usr/include/stdio.h" 2 3 4



# 431 "src/autoconf.h" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4

# 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__const));
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) ;
extern int isalpha (int) ;
extern int iscntrl (int) ;
extern int isdigit (int) ;
extern int islower (int) ;
extern int isgraph (int) ;
extern int isprint (int) ;
extern int ispunct (int) ;
extern int isspace (int) ;
extern int isupper (int) ;
extern int isxdigit (int) ;



extern int tolower (int __c) ;


extern int toupper (int __c) ;


# 142 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) ;



extern int toascii (int __c) ;



extern int _toupper (int) ;
extern int _tolower (int) ;
# 190 "/usr/include/ctype.h" 3 4
extern __inline int
tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline int
toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 323 "/usr/include/ctype.h" 3 4

# 432 "src/autoconf.h" 2


# 1 "/usr/include/fcntl.h" 1 3 4
# 29 "/usr/include/fcntl.h" 3 4




# 1 "/usr/include/bits/fcntl.h" 1 3 4
# 136 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };
# 34 "/usr/include/fcntl.h" 2 3 4
# 63 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 72 "/usr/include/fcntl.h" 3 4
extern int open (__const char *__file, int __oflag, ...);
# 90 "/usr/include/fcntl.h" 3 4
extern int creat (__const char *__file, __mode_t __mode);
# 173 "/usr/include/fcntl.h" 3 4

# 435 "src/autoconf.h" 2




# 1 "/usr/include/sys/socket.h" 1 3 4
# 25 "/usr/include/sys/socket.h" 3 4


# 1 "/usr/include/sys/uio.h" 1 3 4
# 26 "/usr/include/sys/uio.h" 3 4



# 1 "/usr/include/bits/uio.h" 1 3 4
# 42 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 30 "/usr/include/sys/uio.h" 2 3 4
# 40 "/usr/include/sys/uio.h" 3 4
extern ssize_t readv (int __fd, __const struct iovec *__vector, int __count);
# 50 "/usr/include/sys/uio.h" 3 4
extern ssize_t writev (int __fd, __const struct iovec *__vector, int __count);


# 28 "/usr/include/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 30 "/usr/include/sys/socket.h" 2 3 4





# 1 "/usr/include/bits/socket.h" 1 3 4
# 29 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/stddef.h" 1 3 4
# 30 "/usr/include/bits/socket.h" 2 3 4

# 1 "/usr/lib/gcc/i486-linux-gnu/4.0.1/include/limits.h" 1 3 4
# 32 "/usr/include/bits/socket.h" 2 3 4
# 41 "/usr/include/bits/socket.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_PACKET = 10



};
# 142 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
# 29 "/usr/include/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 143 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 162 "/usr/include/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    __uint32_t __ss_align;
    char __ss_padding[(128 - (2 * sizeof (__uint32_t)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,






    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000

  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;

    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;

    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 257 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) ;




extern __inline struct cmsghdr *
__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01,


    SCM_CREDENTIALS = 0x02,


    __SCM_CONNECT = 0x03
  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};


# 1 "/usr/include/asm/socket.h" 1 3 4



# 1 "/usr/include/asm/sockios.h" 1 3 4
# 5 "/usr/include/asm/socket.h" 2 3 4
# 306 "/usr/include/bits/socket.h" 2 3 4



struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 36 "/usr/include/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 100 "/usr/include/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) ;





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) ;


extern int bind (int __fd, __const struct sockaddr * __addr, socklen_t __len)
     ;


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) ;
# 124 "/usr/include/sys/socket.h" 3 4
extern int connect (int __fd, __const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) ;






extern ssize_t send (int __fd, __const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, __const void *__buf, size_t __n,
         int __flags, __const struct sockaddr * __addr,
         socklen_t __addr_len);
# 161 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, __const struct msghdr *__message,
   int __flags);






extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);





extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) ;




extern int setsockopt (int __fd, int __level, int __optname,
         __const void *__optval, socklen_t __optlen) ;





extern int listen (int __fd, int __n) ;
# 209 "/usr/include/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);







extern int shutdown (int __fd, int __how) ;
# 231 "/usr/include/sys/socket.h" 3 4
extern int isfdtype (int __fd, int __fdtype) ;



# 440 "src/autoconf.h" 2

typedef int dbref;
typedef int FLAG;
typedef int POWER;
typedef char boolexp_type;
typedef char IBUF[16];
# 19 "src/hcode/btech/mech.h" 2




# 1 "src/config.h" 1
# 9 "src/config.h"
# 1 "src/copyright.h" 1
# 10 "src/config.h" 2
# 1 "src/autoconf.h" 1
# 11 "src/config.h" 2
# 24 "src/hcode/btech/mech.h" 2
# 1 "src/externs.h" 1





# 1 "src/autoconf.h" 1
# 7 "src/externs.h" 2
# 1 "src/copyright.h" 1
# 8 "src/externs.h" 2




# 1 "src/db.h" 1





# 1 "src/copyright.h" 1
# 7 "src/db.h" 2




# 1 "src/config.h" 1
# 12 "src/db.h" 2
# 1 "src/mudconf.h" 1





# 1 "src/autoconf.h" 1
# 7 "src/mudconf.h" 2




# 1 "/usr/include/netinet/in.h" 1 3 4
# 23 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 28 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 49 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
# 129 "/usr/include/stdint.h" 3 4
typedef unsigned int uintptr_t;
# 138 "/usr/include/stdint.h" 3 4
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;
# 24 "/usr/include/netinet/in.h" 2 3 4







enum
  {
    IPPROTO_IP = 0,

    IPPROTO_HOPOPTS = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_IPV6 = 41,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MTP = 92,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };
# 193 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t u6_addr8[16];
 uint16_t u6_addr16[8];
 uint32_t u6_addr32[4];
      } in6_u;



  };

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 219 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };


struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };


struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };


# 1 "/usr/include/bits/in.h" 1 3 4
# 66 "/usr/include/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreq
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_interface;
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 254 "/usr/include/netinet/in.h" 2 3 4
# 262 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__const__));




# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 274 "/usr/include/netinet/in.h" 2 3 4
# 336 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) ;


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     ;
# 364 "/usr/include/netinet/in.h" 3 4
struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };
# 387 "/usr/include/netinet/in.h" 3 4

# 12 "src/mudconf.h" 2
# 1 "src/config.h" 1
# 13 "src/mudconf.h" 2
# 1 "src/htab.h" 1





# 1 "src/copyright.h" 1
# 7 "src/htab.h" 2




# 1 "src/autoconf.h" 1
# 12 "src/htab.h" 2
# 1 "src/db.h" 1





# 1 "src/copyright.h" 1
# 7 "src/db.h" 2
# 13 "src/htab.h" 2

typedef struct hashentry HASHENT;
struct hashentry {
    char *target;
    int *data;
    int checks;
    struct hashentry *next;
};

typedef struct num_hashentry NHSHENT;
struct num_hashentry {
    int target;
    int *data;
    int checks;
    struct num_hashentry *next;
};

typedef struct hasharray HASHARR;
struct hasharray {
    HASHENT *element[800];
};

typedef struct num_hasharray NHSHARR;
struct num_hasharray {
    NHSHENT *element[800];
};

typedef struct hashtable HASHTAB;
struct hashtable {
    int hashsize;
    int mask;
    int checks;
    int scans;
    int max_scan;
    int hits;
    int entries;
    int deletes;
    int nulls;
    HASHARR *entry;
    int last_hval;
    HASHENT *last_entry;
};

typedef struct num_hashtable NHSHTAB;
struct num_hashtable {
    int hashsize;
    int mask;
    int checks;
    int scans;
    int max_scan;
    int hits;
    int entries;
    int deletes;
    int nulls;
    NHSHARR *entry;
    int last_hval;
    NHSHENT *last_entry;
};

typedef struct name_table NAMETAB;
struct name_table {
    char *name;
    int minlen;
    int perm;
    int flag;
};



typedef struct bque BQUE;
struct bque {
    BQUE *next;
    dbref player;
    dbref cause;
    dbref sem;
    int waittime;
    int attr;
    char *text;
    char *comm;
    char *env[10];
    char *scr[10];
    int nargs;
};

extern void hashinit(HASHTAB *, int);
extern void hashreset(HASHTAB *);
extern int hashval(char *, int);
extern int get_hashmask(int *);
extern int *hashfind(char *, HASHTAB *);
extern int hashadd(char *, int *, HASHTAB *);
extern void hashdelete(char *, HASHTAB *);
extern void hashflush(HASHTAB *, int);
extern int hashrepl(char *, int *, HASHTAB *);
extern void hashreplall(int *, int *, HASHTAB *);
extern char *hashinfo(const char *, HASHTAB *);
extern int *nhashfind(int, NHSHTAB *);
extern int nhashadd(int, int *, NHSHTAB *);
extern void nhashdelete(int, NHSHTAB *);
extern void nhashflush(NHSHTAB *, int);
extern int nhashrepl(int, int *, NHSHTAB *);
extern int search_nametab(dbref, NAMETAB *, char *);
extern NAMETAB *find_nametab_ent(dbref, NAMETAB *, char *);
extern void display_nametab(dbref, NAMETAB *, char *, int);
extern void interp_nametab(dbref, NAMETAB *, int, char *, char *, char *);
extern void listset_nametab(dbref, NAMETAB *, int, char *, int);
extern int *hash_nextentry(HASHTAB * htab);
extern int *hash_firstentry(HASHTAB * htab);
extern char *hash_firstkey(HASHTAB * htab);
extern char *hash_nextkey(HASHTAB * htab);
extern int *nhash_nextentry(NHSHTAB * htab);
extern int *nhash_firstentry(NHSHTAB * htab);

extern NAMETAB powers_nametab[];
# 14 "src/mudconf.h" 2
# 1 "src/alloc.h" 1





# 1 "src/copyright.h" 1
# 7 "src/alloc.h" 2
# 33 "src/alloc.h"
extern void pool_init(int, int);
extern char *pool_alloc(int, const char *);
extern void pool_free(int, char **);
extern void list_bufstats(dbref);
extern void list_buftrace(dbref);
# 15 "src/mudconf.h" 2
# 1 "src/flags.h" 1





# 1 "src/copyright.h" 1
# 7 "src/flags.h" 2




# 1 "src/htab.h" 1





# 1 "src/copyright.h" 1
# 7 "src/htab.h" 2
# 12 "src/flags.h" 2
# 1 "src/db.h" 1





# 1 "src/copyright.h" 1
# 7 "src/db.h" 2
# 13 "src/flags.h" 2
# 261 "src/flags.h"
typedef struct flag_entry {
    const char *flagname;
    int flagvalue;
    char flaglett;
    int flagflag;
    int listperm;
    int (*handler) ();
} FLAGENT;





typedef struct object_entry {
    const char *name;
    char lett;
    int perm;
    int flags;
} OBJENT;
extern OBJENT object_types[8];
# 290 "src/flags.h"
typedef struct flagset {
    FLAG word1;
    FLAG word2;
    FLAG word3;
} FLAGSET;

extern void init_flagtab(void);
extern void display_flagtab(dbref);
extern void flag_set(dbref, dbref, char *, int);
extern char *flag_description(dbref, dbref);
extern FLAGENT *find_flag(dbref, char *);
extern char *decode_flags(dbref, FLAG, int, int);
extern int has_flag(dbref, dbref, char *);
extern char *unparse_object(dbref, dbref, int);
extern char *unparse_object_numonly(dbref);
extern int convert_flags(dbref, char *, FLAGSET *, FLAG *);
extern void decompile_flags(dbref, dbref, char *);
# 16 "src/mudconf.h" 2
# 1 "src/mail.h" 1
# 9 "src/mail.h"
# 1 "src/copyright.h" 1
# 10 "src/mail.h" 2
# 1 "src/autoconf.h" 1
# 11 "src/mail.h" 2
# 1 "src/db.h" 1





# 1 "src/copyright.h" 1
# 7 "src/db.h" 2
# 12 "src/mail.h" 2
# 62 "src/mail.h"
typedef unsigned int mail_flag;

struct mail {
    struct mail *next;
    struct mail *prev;
    dbref to;
    dbref from;
    int number;
    const char *time;
    const char *subject;
    const char *tolist;
    int read;
};

struct mail_selector {
    int low, high;
    mail_flag flags;
    dbref player;
    int days, day_comp;
};

struct muser {
    dbref who;
    char *fwd;
    char *vacation;
    dbref *afilter;
    int status;
};

typedef struct mail_entry MENT;
struct mail_entry {
    char *message;
    int count;
};

extern void set_player_folder(dbref, int);
extern void do_malias_send(dbref, char *, char *, char *, int, mail_flag, int);
extern struct malias *get_malias(dbref, char *);
extern void load_malias(FILE *);
extern void save_malias(FILE *);
extern void malias_read(FILE *);
extern void malias_write(FILE *);
extern void do_malias_chown(dbref, char *, char *);
extern void do_malias_desc(dbref, char *, char *);
extern void do_expmail_start(dbref, char *, char *);
extern void do_expmail_stop(dbref, int);
extern void do_mail_quick(dbref, char *, char *);
extern void do_malias_rename(dbref, char *, char *);
extern void do_malias_adminlist(dbref);
extern void do_malias_delete(dbref, char *);
extern void do_malias_status(dbref);
extern void do_malias_create(dbref, char *, char *);
extern void do_malias_list(dbref, char *);
extern void do_malias_list_all(dbref);
extern void do_malias_add(dbref, char *, char *);
extern void do_malias_remove(dbref, char *, char *);
extern void check_mail_expiration(void);
extern void check_mail(dbref, int, int);
extern void do_mail_purge(dbref);
# 17 "src/mudconf.h" 2
# 1 "src/db.h" 1





# 1 "src/copyright.h" 1
# 7 "src/db.h" 2
# 18 "src/mudconf.h" 2



typedef unsigned char Uchar;

typedef struct confdata CONFDATA;
struct confdata {
    int cache_trim;
    int cache_steal_dirty;
    int cache_depth;
    int cache_width;
    int cache_names;

    char indb[128];
    char outdb[128];
    char crashdb[128];
    char gdbm[128];
    char mail_db[128];
    char commac_db[128];
    char hcode_db[128];

    char econ_db[128];

    char mech_db[128];
    char map_db[128];
    char config_file[128];
    int compress_db;
    char compress[128];
    char uncompress[128];
    char status_file[128];
    int have_specials;
    int have_comsys;
    int have_macros;
    int have_mailer;
    int have_zones;
    int port;
    int conc_port;
    int init_size;
    int have_guest;
    int guest_char;
    int guest_nuker;
    int number_guests;
    char guest_prefix[32];
    char guest_file[32];
    char conn_file[32];
    char conn_dir[32];
    char creg_file[32];
    char regf_file[32];
    char motd_file[32];
    char wizmotd_file[32];
    char quit_file[32];
    char down_file[32];
    char full_file[32];
    char site_file[32];
    char crea_file[32];
    char help_file[32];
    char help_indx[32];
    char news_file[32];
    char news_indx[32];
    char whelp_file[32];
    char whelp_indx[32];
    char plushelp_file[32];
    char plushelp_indx[32];
    char wiznews_file[32];
    char wiznews_indx[32];
    char motd_msg[4096];
    char wizmotd_msg[4096];
    char downmotd_msg[4096];
    char fullmotd_msg[4096];
    char dump_msg[128];
    char postdump_msg[128];
    char fixed_home_msg[128];
    char fixed_tel_msg[128];
    char public_channel[32];
    char guests_channel[32];
    char pueblo_msg[1024];
    int allow_unloggedwho;
    int btech_engine;
    int btech_ic;
    int btech_parts;
    int btech_vcrit;
    int btech_slowdown;
    int btech_fasaturn;
    int btech_dynspeed;
    int btech_stackpole;
    int btech_erange;
    int phys_use_pskill;
    int namechange_days;
    int allow_chanlurking;
    int btech_newterrain;
    int btech_fasacrit;
    int btech_fasaadvvtolcrit;
    int btech_fasaadvvhlcrit;
    int btech_fasaadvvhlfire;
    int btech_divrotordamage;
    int btech_moddamagewithrange;
    int btech_moddamagewithwoods;
    int btech_hotloadaddshalfbthmod;
    int btech_nofusionvtolfuel;
    int btech_vhltacthreshold;
    int btech_mechtacthreshold;
    int btech_newcharge;
    int btech_tankfriendly;
    int btech_skidcliff;
    int btech_xp_bthmod;
    int btech_xp_missilemod;
    int btech_xp_ammomod;
    int btech_defaultweapdam;
    int btech_xp_usePilotBVMod;
    int btech_xp_modifier;
    int btech_defaultweapbv;
    int btech_oldxpsystem;
    int btech_xp_vrtmod;
    int btech_limitedrepairs;
    int btech_digbonus;
    int btech_dig_only_fs;
    int btech_xploss;
    int btech_critlevel;
    int btech_tankshield;
    int btech_newstagger;
    int btech_extendedmovemod;
    int btech_stacking;
    int btech_stackdamage;
    int btech_mw_losmap;

    int btech_usedmechstore;
    int btech_ooc_comsys;
# 153 "src/mudconf.h"
    int hudinfo_show_mapinfo;
    int hudinfo_enabled;

    int afterlife_dbref;
    int afterscen_dbref;
    int indent_desc;
    int name_spaces;
    int site_chars;
    int fork_dump;
    int fork_vfork;
    int sig_action;
    int paranoid_alloc;
    int max_players;
    int dump_interval;
    int check_interval;
    int events_daily_hour;
    int dump_offset;
    int check_offset;
    int idle_timeout;
    int conn_timeout;
    int idle_interval;
    int retry_limit;
    int output_limit;
    int paycheck;
    int paystart;
    int paylimit;
    int start_quota;
    int payfind;
    int digcost;
    int linkcost;
    int opencost;
    int createmin;
    int createmax;
    int killmin;
    int killmax;
    int killguarantee;
    int robotcost;
    int pagecost;
    int searchcost;
    int waitcost;
    int mail_expiration;
    int use_http;
    int queuemax;
    int queue_chunk;
    int active_q_chunk;
    int machinecost;
    int room_quota;
    int exit_quota;
    int thing_quota;
    int player_quota;
    int sacfactor;
    int sacadjust;
    int clone_copy_cost;
    int use_hostname;
    int quotas;
    int ex_flags;
    int robot_speak;
    int pub_flags;
    int quiet_look;
    int exam_public;
    int read_rem_desc;
    int read_rem_name;
    int sweep_dark;
    int player_listen;
    int quiet_whisper;
    int dark_sleepers;
    int see_own_dark;
    int idle_wiz_dark;
    int pemit_players;
    int pemit_any;
    int match_mine;
    int match_mine_pl;
    int switch_df_all;
    int fascist_tport;
    int terse_look;
    int terse_contents;
    int terse_exits;
    int terse_movemsg;
    int trace_topdown;
    int trace_limit;
    int stack_limit;
    int safe_unowned;
    int space_compress;
    int start_room;
    int start_home;
    int default_home;
    int master_room;
    FLAGSET player_flags;
    FLAGSET room_flags;
    FLAGSET exit_flags;
    FLAGSET thing_flags;
    FLAGSET robot_flags;
    int vattr_flags;
    char mud_name[32];
    char one_coin[32];
    char many_coins[32];
    int timeslice;
    int cmd_quota_max;
    int cmd_quota_incr;
    int control_flags;
    int log_options;
    int log_info;
    Uchar markdata[8];
    int func_nest_lim;
    int func_invk_lim;
    int ntfy_nest_lim;
    int lock_nest_lim;
    int parent_nest_lim;
    int zone_nest_lim;
# 318 "src/mudconf.h"
    int room_parent;
    int exit_parent;

};

extern CONFDATA mudconf;

typedef struct site_data SITE;
struct site_data {
    struct site_data *next;
    struct in_addr address;
    struct in_addr mask;
    int flag;
};

typedef struct objlist_block OBLOCK;
struct objlist_block {
    struct objlist_block *next;
    dbref data[(8000 - sizeof(OBLOCK *)) / sizeof(dbref)];
};



typedef struct objlist_stack OLSTK;
struct objlist_stack {
        struct objlist_stack *next;
        OBLOCK *head;
        OBLOCK *tail;
        OBLOCK *cblock;
        int count;
        int citm;
};

typedef struct markbuf MARKBUF;
struct markbuf {
    char chunk[5000];
};

typedef struct alist ALIST;
struct alist {
    char *data;
    int len;
    struct alist *next;
};

typedef struct badname_struc BADNAME;
struct badname_struc {
    char *name;
    struct badname_struc *next;
};

typedef struct forward_list FWDLIST;
struct forward_list {
    int count;
    int data[1000];
};

typedef struct statedata STATEDATA;
struct statedata {
    int record_players;

    int initializing;
    int panicking;
    int restarting;
    int dumping;
    int logging;
    int epoch;
    int generation;
    dbref curr_enactor;
    dbref curr_player;
    int alarm_triggered;
    time_t now;
    time_t dump_counter;
    time_t check_counter;
    time_t idle_counter;
    time_t mstats_counter;
    time_t events_counter;
    int events_flag;
    int events_lasthour;

    int shutdown_flag;
    char version[128];
    time_t start_time;
    time_t restart_time;
    char buffer[256];
    char *debug_cmd;
    char doing_hdr[41];
    SITE *access_list;
    SITE *suspect_list;
    HASHTAB command_htab;
    HASHTAB macro_htab;
    HASHTAB channel_htab;
    NHSHTAB mail_htab;
    HASHTAB logout_cmd_htab;
    HASHTAB func_htab;
    HASHTAB ufunc_htab;
    HASHTAB powers_htab;
    HASHTAB flags_htab;
    HASHTAB attr_name_htab;
    HASHTAB vattr_name_htab;
    HASHTAB player_htab;
    NHSHTAB desc_htab;
    NHSHTAB fwdlist_htab;
    NHSHTAB parent_htab;



    HASHTAB news_htab;
    HASHTAB help_htab;
    HASHTAB wizhelp_htab;
    HASHTAB plushelp_htab;
    HASHTAB wiznews_htab;
    int attr_next;
    BQUE *qfirst;
    BQUE *qlast;
    BQUE *qlfirst;
    BQUE *qllast;
    BQUE *qwait;
    BQUE *qsemfirst;
    BQUE *qsemlast;
    BADNAME *badname_head;
    int mstat_ixrss[2];
    int mstat_idrss[2];
    int mstat_isrss[2];
    int mstat_secs[2];
    int mstat_curr;
    ALIST iter_alist;
    char *mod_alist;
    int mod_size;
    dbref mod_al_id;
    OLSTK *olist;
    dbref freelist;
    int min_size;
    int db_top;
    int db_size;
    int mail_freelist;
    int mail_db_top;
    int mail_db_size;
    MENT *mail_list;
    int *guest_free;
    MARKBUF *markbits;
    int func_nest_lev;
    int func_invk_ctr;
    int ntfy_nest_lev;
    int lock_nest_lev;
    char *global_regs[10];
    int zone_nest_num;
    int inpipe;
    char *pout;
    char *poutnew;
    char *poutbufc;
    dbref poutobj;
# 485 "src/mudconf.h"
};

extern STATEDATA mudstate;
# 13 "src/db.h" 2

# 1 "/usr/include/sys/file.h" 1 3 4
# 28 "/usr/include/sys/file.h" 3 4

# 51 "/usr/include/sys/file.h" 3 4
extern int flock (int __fd, int __operation) ;



# 15 "src/db.h" 2
# 37 "src/db.h"
int get_atr();

typedef struct attr ATTR;
struct attr {
    const char *name;
    int number;
    int flags;
    int (*check)(int, dbref, dbref, int, char *);
};


typedef struct atrlist ATRLIST;
struct atrlist {
    char *data;
    int size;
    int number;
};


typedef struct stack STACK;
struct stack {
    char *data;
    STACK *next;
};

extern ATTR *atr_num(int anum);
extern ATTR *atr_str(char *s);

extern ATTR attr[];

extern ATTR **anum_table;



extern void anum_extend(int);
# 87 "src/db.h"
typedef struct boolexp BOOLEXP;
struct boolexp {
    boolexp_type type;
    struct boolexp *sub1;
    struct boolexp *sub2;
    dbref thing;
};
# 140 "src/db.h"
typedef struct object OBJ;
struct object {
    dbref location;


    dbref contents;

    dbref exits;

    dbref next;


    dbref link;

    dbref parent;
    dbref owner;


    dbref zone;

    FLAG flags;
    FLAG flags2;
    FLAG flags3;

    POWER powers;
    POWER powers2;

    STACK *stackhead;


    ATRLIST *ahead;
    int at_count;

};

typedef char *NAME;

extern OBJ *db;
extern NAME *names;
# 225 "src/db.h"
extern int Pennies(dbref);
extern void s_Pennies(dbref, int);

extern dbref getref(FILE *);
extern void putref(FILE *, dbref);
extern BOOLEXP *dup_bool(BOOLEXP *);
extern void free_boolexp(BOOLEXP *);
extern dbref parse_dbref(const char *);
extern int mkattr(char *);
extern void al_add(dbref, int);
extern void al_delete(dbref, int);
extern void al_destroy(dbref);
extern void al_store(void);
extern void db_grow(dbref);
extern void db_free(void);
extern void db_make_minimal(void);
extern dbref db_read(FILE *, int *, int *, int *);
extern dbref db_write(FILE *, int, int);
extern void destroy_thing(dbref);
extern void destroy_exit(dbref);
extern void load_restart_db(void);
extern void dump_database_internal(int);
# 13 "src/externs.h" 2
# 1 "src/mudconf.h" 1





# 1 "src/autoconf.h" 1
# 7 "src/mudconf.h" 2
# 14 "src/externs.h" 2
# 1 "src/regexp.h" 1
# 19 "src/regexp.h"
typedef struct regexp {
    char *startp[10];
    char *endp[10];
    char regstart;
    char reganch;
    char *regmust;
    int regmlen;
    char program[1];
} regexp;
# 15 "src/externs.h" 2
# 32 "src/externs.h"
extern regexp *regcomp(char *);
extern int regexec(register regexp *, register char *);
extern void regerror(char *);
extern char regexp_errbuf[];


extern int cf_modify_bits(int *, char *, long, dbref, char *);


extern int load_mail(FILE *);
extern int dump_mail(FILE *);
extern void mail_init(void);
extern struct mail *mail_fetch(dbref, int);


extern int dddb_close(void);
extern int dddb_setfile(char *);
extern int dddb_init(void);


extern void raw_notify_html(dbref, const char *);
extern void make_ulist(dbref, char *, char **);
extern int fetch_idle(dbref);
extern int fetch_connect(dbref);
extern void raw_broadcast(int, char *, ...);


extern int nfy_que(dbref, int, int, int);
extern int halt_que(dbref, dbref);
extern void wait_que(dbref, dbref, int, dbref, int, char *, char *[], int, char *[]);
extern int que_next(void);
extern int do_top(int ncmds);
extern void recover_queue_deposits(void);


extern void tcache_init(void);
extern char *parse_to(char **, char, int);
extern char *parse_arglist(dbref, dbref, char *, char, int, char *[], int, char *[], int);
extern int get_gender(dbref);
extern void exec(char *, char **, int, dbref, dbref, int, char **, char *[], int);
# 98 "src/externs.h"
extern void notify_except(dbref, dbref, dbref, const char *);
extern void notify_except2(dbref, dbref, dbref, dbref, const char *);
extern int check_filter(dbref, dbref, int, const char *);
extern void notify_check(dbref, dbref, const char *, int);
extern int Hearer(dbref);
extern void report(void);
extern int atr_match(dbref, dbref, char, char *, int);
extern int list_check(dbref, dbref, char, char *, int);
extern int html_escape(const char *src, char *dest, char **destp);


extern int helpindex_read(HASHTAB *, char *);
extern void helpindex_load(dbref);
extern void helpindex_init(void);


extern int cf_ntab_access(int *, char *, long, dbref, char *);


extern char *strip_ansi(const char *);
extern char *normal_to_white(const char *);
extern int start_log(const char *, const char *);
extern void end_log(void);
extern void log_perror(const char *, const char *, const char *, const char *);
extern void log_text(char *);
extern void log_number(int);
extern void log_name(dbref);
extern void log_name_and_loc(dbref);
extern char *OBJTYP(dbref);
extern void log_type_and_name(dbref);
extern void log_type_and_num(dbref);

extern int log_to_file(dbref, const char *, const char *);



extern void look_in(dbref, dbref, int);
extern void show_vrml_url(dbref, dbref);


extern void move_object(dbref, dbref);
extern void move_via_generic(dbref, dbref, dbref, int);
extern void move_via_exit(dbref, dbref, dbref, dbref, int);
extern int move_via_teleport(dbref, dbref, dbref, int);
extern void move_exit(dbref, dbref, int, const char *, int);
extern void do_enter_internal(dbref, dbref, int);


extern void destroy_player(dbref);
extern dbref start_home(void);
extern dbref default_home(void);
extern int can_set_home(dbref, dbref, dbref);
extern dbref new_home(dbref);
extern dbref clone_home(dbref, dbref);
extern void divest_object(dbref);
extern dbref create_obj(dbref, int, char *, int);
extern void destroy_obj(dbref, dbref);
extern void empty_obj(dbref);


extern void record_login(dbref, int, char *, char *, char *);
extern int check_pass(dbref, const char *);
extern dbref connect_player(char *, char *, char *, char *);
extern dbref create_player(char *, char *, dbref, int, int);
extern int add_player_name(dbref, char *);
extern int delete_player_name(dbref, char *);
extern dbref lookup_player(dbref, char *, int);
extern void load_player_names(void);
extern void badname_add(char *);
extern void badname_remove(char *);
extern int badname_check(char *);
extern void badname_list(dbref, const char *);


extern char *tprintf(const char *, ...);
extern void safe_tprintf_str(char *, char **, const char *, ...);
extern dbref insert_first(dbref, dbref);
extern dbref remove_first(dbref, dbref);
extern dbref reverse_list(dbref);
extern int member(dbref, dbref);
extern int is_integer(char *);
extern int is_number(char *);
extern int could_doit(dbref, dbref, int);
extern int can_see(dbref, dbref, int);
extern void add_quota(dbref, int);
extern int canpayfees(dbref, dbref, int, int);
extern void giveto(dbref, int);
extern int payfor(dbref, int);
extern int ok_name(const char *);
extern int ok_player_name(const char *);
extern int ok_attr_name(const char *);
extern int ok_password(const char *);
extern void handle_ears(dbref, int, int);
extern void handle_xcode(dbref, dbref, int, int);
extern int HandledCommand(dbref, dbref, char *);
extern dbref match_possessed(dbref, dbref, char *, dbref, int);
extern void parse_range(char **, dbref *, dbref *);
extern int parse_thing_slash(dbref, char *, char **, dbref *);
extern int get_obj_and_lock(dbref, char *, dbref *, ATTR **, char *, char **);
extern dbref where_is(dbref);
extern dbref where_room(dbref);
extern int locatable(dbref, dbref, dbref);
extern int nearby(dbref, dbref);
extern int exit_visible(dbref, dbref, int);
extern int exit_displayable(dbref, dbref, int);
extern void did_it(dbref, dbref, int, const char *, int, const char *, int, char *[], int);
extern void list_bufstats(dbref);
extern void list_buftrace(dbref);


extern int parse_attrib(dbref, char *, dbref *, int *);
extern int parse_attrib_wild(dbref, char *, dbref *, int, int, int);
extern void edit_string(char *, char **, char *, char *);
extern dbref match_controlled(dbref, const char *);
extern dbref match_affected(dbref, const char *);
extern dbref match_examinable(dbref, const char *);


extern char *munge_space(char *);
extern char *trim_spaces(char *);
extern char *grabto(char **, char);
extern int string_compare(const char *, const char *);
extern int string_prefix(const char *, const char *);
extern const char *string_match(const char *, const char *);
extern char *dollar_to_space(const char *);
extern char *replace_string(const char *, const char *, const char *);
extern char *replace_string_inplace(const char *, const char *, char *);
extern char *skip_space(const char *);
extern char *seek_char(const char *, char);
extern int prefix_match(const char *, const char *);
extern int minmatch(char *, char *, int);
extern char *strsave(const char *);
extern int safe_copy_str(char *, char *, char **, int);
extern int safe_copy_chr(char, char *, char **, int);
extern int matches_exit_from_list(char *, char *);
extern char *translate_string(const char *, int);


extern int eval_boolexp(dbref, dbref, dbref, BOOLEXP *);
extern BOOLEXP *parse_boolexp(dbref, const char *, int);
extern int eval_boolexp_atr(dbref, dbref, dbref, char *);


extern int xlate(char *);


extern char *unparse_boolexp(dbref, BOOLEXP *);
extern char *unparse_boolexp_quiet(dbref, BOOLEXP *);
extern char *unparse_boolexp_decompile(dbref, BOOLEXP *);
extern char *unparse_boolexp_function(dbref, BOOLEXP *);


extern int chown_all(dbref, dbref);
extern void olist_push(void);
extern void olist_pop(void);
extern void olist_add(dbref);
extern dbref olist_first(void);
extern dbref olist_next(void);


extern int wild(char *, char *, char *[], int);
extern int wild_match(char *, char *);
extern int quick_wild(char *, char *);


extern const char *uncompress(const char *, int);
extern const char *compress(const char *, int);
extern char *uncompress_str(char *, const char *, int);


extern int check_access(dbref, int);
extern void set_prefix_cmds(void);


extern int Commer(dbref);
extern void s_Pass(dbref, const char *);
extern void s_Name(dbref, char *);
extern char *Name(dbref);
extern char *PureName(dbref);
extern int fwdlist_load(FWDLIST *, dbref, char *);
extern void fwdlist_set(dbref, FWDLIST *);
extern void fwdlist_clr(dbref);
extern int fwdlist_rewrite(FWDLIST *, char *);
extern FWDLIST *fwdlist_get(dbref);
extern void clone_object(dbref, dbref);
extern void init_min_db(void);
extern void atr_push(void);
extern void atr_pop(void);
extern int atr_head(dbref, char **);
extern int atr_next(char **);
extern int init_gdbm_db(char *);
extern void atr_cpy(dbref, dbref, dbref);
extern void atr_chown(dbref);
extern void atr_clr(dbref, int);
extern void atr_add_raw(dbref, int, char *);
extern void atr_add(dbref, int, char *, dbref, int);
extern void atr_set_owner(dbref, int, dbref);
extern void atr_set_flags(dbref, int, int);
extern char *atr_get_raw(dbref, int);
extern char *atr_get(dbref, int, dbref *, int *);
extern char *atr_pget(dbref, int, dbref *, int *);
extern char *atr_get_str(char *, dbref, int, dbref *, int *);
extern char *atr_pget_str(char *, dbref, int, dbref *, int *);
extern int atr_get_info(dbref, int, dbref *, int *);
extern int atr_pget_info(dbref, int, dbref *, int *);
extern void atr_free(dbref);
extern int check_zone(dbref, dbref);
extern int check_zone_for_player(dbref, dbref);
extern void toast_player(dbref);


extern void DisposeSpecialObject(dbref, dbref);
extern void UpdateSpecialObjects(void);
extern void LoadSpecialObjects(void);
extern void ResetSpecialObjects(void);
extern void SaveSpecialObjects(int);
extern void helpindex_faction_load(dbref);
extern void list_fhashstats(dbref);
extern void list_chashstats(dbref);
# 25 "src/hcode/btech/mech.h" 2
# 1 "src/db.h" 1





# 1 "src/copyright.h" 1
# 7 "src/db.h" 2
# 26 "src/hcode/btech/mech.h" 2
# 1 "src/attrs.h" 1





# 1 "src/autoconf.h" 1
# 7 "src/attrs.h" 2




# 1 "src/copyright.h" 1
# 12 "src/attrs.h" 2
# 27 "src/hcode/btech/mech.h" 2
# 1 "src/powers.h" 1





# 1 "src/copyright.h" 1
# 7 "src/powers.h" 2




# 1 "src/htab.h" 1





# 1 "src/copyright.h" 1
# 7 "src/htab.h" 2
# 12 "src/powers.h" 2
# 1 "src/db.h" 1





# 1 "src/copyright.h" 1
# 7 "src/db.h" 2
# 13 "src/powers.h" 2
# 70 "src/powers.h"
typedef struct power_entry {
    const char *powername;
    int powervalue;
    int powerpower;
    int listperm;
    int (*handler) ();
} POWERENT;

typedef struct powerset {
    POWER word1;
    POWER word2;
} POWERSET;

extern void init_powertab(void);
extern void display_powertab(dbref);
extern void power_set(dbref, dbref, char *, int);
extern char *power_description(dbref, dbref);
extern POWERENT *find_power(dbref, char *);
extern int has_power(dbref, dbref, char *);
extern void decompile_powers(dbref, dbref, char *);
extern int decode_power(dbref, char *, POWERSET *);
# 28 "src/hcode/btech/mech.h" 2
# 1 "src/hcode/btech/mech.stat.h" 1
# 20 "src/hcode/btech/mech.stat.h"
typedef struct {
    int rolls[11];
    int hitrolls[11];
    int critrolls[11];
    int totrolls;
    int tothrolls;
    int totcrolls;
} stat_type;


extern stat_type rollstat;
# 29 "src/hcode/btech/mech.h" 2

# 1 "src/hcode/include/btconfig.h" 1
# 367 "src/hcode/include/btconfig.h"
typedef unsigned char byte;
# 31 "src/hcode/btech/mech.h" 2
# 1 "src/hcode/btech/mymath.h" 1
# 32 "src/hcode/btech/mech.h" 2
# 455 "src/hcode/btech/mech.h"
struct weapon_struct {
    char *name;
    char vrt;
    char type;
    char heat;
    char damage;
    char min;
    int shortrange;
    int medrange;
    int longrange;
    char min_water;
    int shortrange_water;
    int medrange_water;
    int longrange_water;
    char criticals;
    unsigned char ammoperton;
    unsigned short weight;
    short explosiondamage;
    long special;
    int battlevalue;
};
# 512 "src/hcode/btech/mech.h"
struct missile_hit_table_struct {
    char *name;
    int key;
    int num_missiles[11];
};
# 573 "src/hcode/btech/mech.h"
struct critical_slot {
    unsigned char brand;
    unsigned char data;
    unsigned short type;
    unsigned int firemode;
    unsigned int ammomode;
    unsigned int weapDamageFlags;
    short desiredAmmoLoc;
};
# 644 "src/hcode/btech/mech.h"
struct section_struct {
    unsigned char armor;
    unsigned char internal;
    unsigned char rear;
    unsigned char armor_orig;
    unsigned char internal_orig;
    unsigned char rear_orig;
    char basetohit;
    char config;
    char recycle;
    unsigned short specials;
    struct critical_slot criticals[12];
};
# 720 "src/hcode/btech/mech.h"
typedef struct {
    char mech_name[31];
    char mech_type[15];
    char type;
    char move;
    char tac_range;
    char lrs_range;
    char scan_range;
    char numsinks;
    char computer;
    char radio;
    unsigned char radioinfo;

    char si;
    char si_orig;

    short radio_range;

    struct section_struct sections[8];
    int fuel;
    int fuel_orig;

    int tons;
    int walkspeed;
    int runspeed;
    float maxspeed;

    int mechbv;
    int cargospace;



    int mechbv_last;


    char targcomp;
    char unused_char[3];


    char carmaxton;

} mech_ud;

typedef struct {
    char jumptop;
    char aim;
    char basetohit;
    char pilotskillbase;
    char engineheat;
    char masc_value;
    char aim_type;

    char sensor[2];
    byte fire_adjustment;
    char vis_mod;


    char chargetimer;
    char chargedist;
    char staggerstamp;

    short mech_prefs;
    short jumplength;
    short goingx, goingy;
    short desiredfacing;
    short angle;
    short jumpheading;
    short targx, targy, targz;
    short turretfacing;
    short turndamage;
    short lateral;
    short num_seen;
    short lx, ly;


    dbref chgtarget;
    dbref dfatarget;
    dbref target;
    dbref swarming;
    dbref carrying;
    dbref spotter;

    float heat;
    float weapheat;
    float plus_heat;
    float minus_heat;

    float startfx, startfy;
    float startfz, endfz;
    float verticalspeed;
    float speed;
    float desired_speed;
    float jumpspeed;

    int critstatus;
    int status;
    int status2;
    int specials;
    int specials2;
    int specialsstatus;
    int tankcritstatus;

    time_t last_weapon_recycle;




    int cargo_weight;


    int lastrndu;
    int rnd;

    int last_ds_msg;
    int boom_start;

    int maxfuel;
    int lastused;
    int cocoon;
    int commconv;
    int commconv_last;
    int onumsinks;
    int disabled_hs;
    int autopilot_num;
    int heatboom_last;
    int sspin;
    int can_see;
    int row;
    int rcw;
    float rspd;
    int erat;
    int per;
    int wxf;
    int last_startup;
    int maxsuits;
    int infantry_specials;
    char scharge_value;
    int staggerDamage;
    int lastStaggerNotify;
    int unused[5];
} mech_rd;

typedef struct {
    char pilotstatus;
    char terrain;
    char elev;
    short hexes_walked;
    short facing;
    short x, y, z;
    short last_x, last_y;
    float fx, fy, fz;
    int team;
    int unusable_arcs;
    int stall;
    dbref pilot;
    dbref bay[4];
    dbref turret[3];
} mech_pd;

typedef struct {
    char C3ChanTitle[15 + 1];
    dbref C3iNetwork[5];
    int wC3iNetworkSize;
    dbref C3Network[11];
    int wC3NetworkSize;
    int wTotalC3Masters;
    int wWorkingC3Masters;
    int C3FreqMode;
    dbref tagTarget;
    dbref taggedBy;
} mech_sd;

typedef struct {
    char ID[2];
    char brief;
    char chantitle[16][15 + 1];
    dbref mynum;
    int mapnumber;
    dbref mapindex;
    unsigned long tic[4][(96 / 32)];
    int freq[16];
    int freqmodes[16];
    mech_ud ud;
    mech_pd pd;
    mech_rd rd;
    mech_sd sd;

} MECH;

struct spot_data {
    float tarFX;
    float tarFY;
    float mechFX;
    float mechFY;
    MECH *target;
};

struct repair_data {
    int delta;
    int time;
    int target;
    int code;
};
# 1249 "src/hcode/btech/mech.h"
extern struct weapon_struct MechWeapons[];
extern struct missile_hit_table_struct MissileHitTable[];
# 1262 "src/hcode/btech/mech.h"
extern void *FindObjectsData(dbref key);
# 1283 "src/hcode/btech/mech.h"
# 1 "src/hcode/btech/btmacros.h" 1
# 26 "src/hcode/btech/btmacros.h"
# 1 "src/hcode/include/macros.h" 1
# 27 "src/hcode/btech/btmacros.h" 2
# 1 "src/hcode/btech/floatsim.h" 1
# 28 "src/hcode/btech/btmacros.h" 2
# 1 "include/muxevent.h" 1
# 50 "include/muxevent.h"
typedef struct my_event_type {
    char flags;
    void (*function) (struct my_event_type *);
    void *data;
    void *data2;
    int tick;
    char type;







    struct my_event_type *next;
    struct my_event_type *next_in_main;
    struct my_event_type *prev_in_main;
    struct my_event_type *prev_in_type;
    struct my_event_type *next_in_type;
} EVENT;


extern int muxevent_tick;
extern int events_scheduled;
extern int events_executed;
extern int events_zombies;

# 1 "include/p.event.h" 1
# 16 "include/p.event.h"
void muxevent_add(int time, int flags, int type, void (*func) (EVENT *),
    void *data, void *data2);
void muxevent_run(void);
int muxevent_run_by_type(int type);
int muxevent_last_type(void);
void muxevent_initialize(void);
void muxevent_remove_data(void *data);
void muxevent_remote_type_data(int type, void *data);
void muxevent_remote_type_data2(int type, void *data);
void muxevent_remote_type_data_data(int type, void *data, void *data2);
int muxevent_type_data(int type, void *data);
void muxevent_get_type_data(int type, void *data, int *data2);
int muxevent_count_type(int type);
int muxevent_count_type_Data(int type, void *data);
int muxevent_count_type_Data2(int type, void *data);
int muxevent_count_type_Data_data(int type, void *data, void *data2);
int muxevent_count_data(int type, void *data);
int muxevent_count_data_data(int type, void *data, void *data2);
void muxevent_gothru_type_data(int type, void *data, void (*func) (EVENT *));
void muxevent_gothru_type(int type, void (*func) (EVENT *));
int muxevent_last_type_data(int type, void *data);
int muxevent_first_type_data(int type, void *data);
int muxevent_count_type_Data_firstev(int type, void *data);
# 78 "include/muxevent.h" 2
# 109 "include/muxevent.h"
void muxevent_add(int time, int flags, int type, void (*func) (EVENT *),
    void *data, void *data2);
void muxevent_gothru_type_data(int type, void *data, void (*func) (EVENT *));
void event_gothru_type(int type, void (*func) (EVENT *));
# 29 "src/hcode/btech/btmacros.h" 2
# 1284 "src/hcode/btech/mech.h" 2
# 1 "src/hcode/include/p.glue.hcode.h" 1
# 16 "src/hcode/include/p.glue.hcode.h"
int bt_get_attr(char *tbuf, int obj, char *name);
char *silly_atr_get(int id, int flag);
void silly_atr_set(int id, int flag, char *dat);
void bt_set_attr(dbref obj, char *attri, char *value);
void KillText(char **mapt);
void ShowText(char **mapt, dbref player);
int BOUNDED(int min, int val, int max);
int MAX(int v1, int v2);
int MIN(int v1, int v2);
int silly_parseattributes(char *buffer, char **args, int max);
int mech_parseattributes(char *buffer, char **args, int maxargs);
# 1285 "src/hcode/btech/mech.h" 2
# 1 "src/hcode/btech/map.h" 1
# 112 "src/hcode/btech/map.h"
typedef struct mapobj_struct {
    short x, y;
    dbref obj;
    char type;
    char datac;
    short datas;
    int datai;
    struct mapobj_struct *next;
} mapobj;
# 150 "src/hcode/btech/map.h"
typedef struct {
    dbref mynum;
    unsigned char **map;
    char mapname[30 + 1];

    short map_width;
    short map_height;

    char temp;

    unsigned char grav;

    short cloudbase;
    char unused_char;
    char mapvis;


    short maxvis;

    char maplight;
    short winddir, windspeed;

    byte flags;

    mapobj *mapobj[10];
    short cf, cfmax;
    dbref onmap;
    char buildflag;

    unsigned char first_free;
    dbref *mechsOnMap;
    unsigned short **LOSinfo;



    char *mechflags;
    short moves;
    short movemod;
    int sensorflags;
} MAP;




# 1 "src/hcode/btech/p.map.bits.h" 1
# 16 "src/hcode/btech/p.map.bits.h"
void map_load_bits(FILE * f, MAP * map);
void map_save_bits(FILE * f, MAP * map, mapobj * obj);
void set_hex_enterable(MAP * map, int x, int y);
void set_hex_mine(MAP * map, int x, int y);
void unset_hex_enterable(MAP * map, int x, int y);
void unset_hex_mine(MAP * map, int x, int y);
int is_mine_hex(MAP * map, int x, int y);
int is_hangar_hex(MAP * map, int x, int y);
void clear_hex_bits(MAP * map, int bits);
int bit_size(MAP * map);
# 195 "src/hcode/btech/map.h" 2
# 1 "src/hcode/btech/p.map.h" 1
# 16 "src/hcode/btech/p.map.h"
void debug_fixmap(dbref player, void *data, char *buffer);
void map_view(dbref player, void *data, char *buffer);
void map_addhex(dbref player, void *data, char *buffer);
void map_mapemit(dbref player, void *data, char *buffer);
int water_distance(MAP * map, int x, int y, int dir, int max);
int map_load(MAP * map, char * mapname);
void map_loadmap(dbref player, void *data, char *buffer);
void map_savemap(dbref player, void *data, char *buffer);
void map_setmapsize(dbref player, void *data, char *buffer);
void map_clearmechs(dbref player, void *data, char *buffer);
void map_update(dbref obj, void *data);
void initialize_map_empty(MAP * new, dbref key);
void newfreemap(dbref key, void **data, int selector);
int map_sizefun(void *data, int flag);
void map_listmechs(dbref player, void *data, char *buffer);
void clear_hex(MECH * mech, int x, int y, int meant);
void map_pathfind(dbref player, void *data, char *buffer);
void UpdateMechsTerrain(MAP * map, int x, int y, int t);
# 196 "src/hcode/btech/map.h" 2
# 1 "src/hcode/btech/p.map.obj.h" 1
# 16 "src/hcode/btech/p.map.obj.h"
mapobj *next_mapobj(mapobj * m);
mapobj *first_mapobj(MAP * map, int type);
void save_mapobjs(FILE * f, MAP * map);
int find_entrance(MAP * map, char dir, int *x, int *y);
char *structure_name(mapobj * mapo);
mapobj *find_entrance_by_target(MAP * map, dbref target);
mapobj *find_entrance_by_xy(MAP * map, int x, int y);
mapobj *find_mapobj(MAP * map, int x, int y, int type);
char find_decorations(MAP * map, int x, int y);
void del_mapobj(MAP * map, mapobj * mapob, int type, int zap);
void del_mapobjst(MAP * map, int type);
void del_mapobjs(MAP * map);
mapobj *add_mapobj(MAP * map, mapobj ** to, mapobj * from, int flag);
int FindXEven(int wind, int x);
int FindYEven(int wind, int y);
int FindXOdd(int wind, int x);
int FindYOdd(int wind, int y);
void CheckForFire(MAP * map, int x[], int y[]);
void CheckForSmoke(MAP * map, int x[], int y[]);
void add_decoration(MAP * map, int x, int y, int type, char data,
    int flaggo);
void load_mapobjs(FILE * f, MAP * map);
void list_mapobjs(dbref player, MAP * map);
void map_addfire(dbref player, void *data, char *buffer);
void map_addsmoke(dbref player, void *data, char *buffer);
void map_add_block(dbref player, void *data, char *buffer);
int is_blocked_lz(MECH * mech, MAP * map, int x, int y);
void map_setlinked(dbref player, void *data, char *buffer);
int mapobj_del(MAP * map, int x, int y, int tt);
void map_delobj(dbref player, void *data, char *buffer);
int parse_coord(MAP * map, int dir, char *data, int *x, int *y);
void add_entrances(dbref loc, MAP * map, char *data);
void add_links(dbref loc, MAP * map, char *data);
void recursively_updatelinks(dbref from, dbref loc);
void map_updatelinks(dbref player, void *data, char *buffer);
int map_linked(dbref mapobj);
int get_cf(dbref d);
void possibly_start_building_regen(dbref obj);
void hit_building(MECH * mech, int x, int y, int weapindx, int damage);
void fire_hex(MECH * mech, int x, int y, int meant);
void steppable_base_check(MECH * mech, int x, int y);
void show_building_in_hex(MECH * mech, int x, int y);
int obj_size(MAP * map);
int map_underlying_terrain(MAP * map, int x, int y);
int mech_underlying_terrain(MECH * mech);
# 197 "src/hcode/btech/map.h" 2
# 1 "src/hcode/btech/p.map.dynamic.h" 1
# 16 "src/hcode/btech/p.map.dynamic.h"
void load_mapdynamic(FILE * f, MAP * map);
void save_mapdynamic(FILE * f, MAP * map);
void mech_map_consistency_check(MECH * mech);
void eliminate_empties(MAP * map);
void remove_mech_from_map(MAP * map, MECH * mech);
void add_mech_to_map(MAP * newmap, MECH * mech);
int mech_size(MAP * map);
# 198 "src/hcode/btech/map.h" 2

extern void newfreemap(dbref key, void **data, int selector);
extern void map_update(dbref obj, void *data);
# 1286 "src/hcode/btech/mech.h" 2
# 1 "src/hcode/btech/map.coding.h" 1
# 22 "src/hcode/btech/map.coding.h"
# 1 "src/hcode/btech/p.map.coding.h" 1
# 16 "src/hcode/btech/p.map.coding.h"
void init_map_coding(void);
int Coding_GetIndex(char terrain, char elevation);
char Coding_GetElevation(int index);
char Coding_GetTerrain(int index);
# 23 "src/hcode/btech/map.coding.h" 2
# 1287 "src/hcode/btech/mech.h" 2
# 1 "src/hcode/include/glue.h" 1
# 46 "src/hcode/include/glue.h"
# 1 "src/hcode/include/glue_types.h" 1
# 47 "src/hcode/include/glue.h" 2



typedef struct CommandsStruct {
    int flag;
    char *name;
    char *helpmsg;
    void (*func) ();
} CommandsStruct;

typedef struct SpecialObjectStruct {
    char *type;
    CommandsStruct *commands;
    long datasize;
    void (*allocfreefunc) ();
    int updateTime;

    void (*updatefunc) ();


    int power_needed;

} SpecialObjectStruct;
# 1078 "src/hcode/include/glue.h"
void send_channel(char *, char *);
# 1288 "src/hcode/btech/mech.h" 2
# 1 "src/hcode/include/p.glue.h" 1
# 16 "src/hcode/include/p.glue.h"
int HandledCommand_sub(dbref player, dbref location, char *command);
int HandledCommand(dbref player, dbref loc, char *command);
void mech_remove_from_all_maps(MECH * mech);
void mech_remove_from_all_maps_except(MECH * mech, int num);
void zap_unneccessary_hcode(void);
void LoadSpecialObjects(void);
void ChangeSpecialObjects(int i);
void SaveSpecialObjects(int i);
void UpdateSpecialObjects(void);
void *NewSpecialObject(int id, int type);
void CreateNewSpecialObject(dbref player, dbref key);
void DisposeSpecialObject(dbref player, dbref key);
void Dump_Mech(dbref player, int type, char *typestr);
void DumpMechs(dbref player);
void DumpMaps(dbref player);
int WhichSpecial(dbref key);
int IsMech(dbref num);
int IsMap(dbref num);
void *FindObjectsData(dbref key);
char *center_string(char *c, int len);
void InitSpecialHash(int which);
void handle_xcode(dbref player, dbref obj, int from, int to);
void initialize_colorize(void);
char *colorize(dbref player, char *from);
void mecha_notify(dbref player, char *msg);
void mecha_notify_except(dbref loc, dbref player, dbref exception,
    char *msg);
void list_chashstats(dbref player);
void ResetSpecialObjects(void);
MAP *getMap(dbref d);
MECH *getMech(dbref d);
# 1289 "src/hcode/btech/mech.h" 2
# 1 "src/hcode/btech/mech.notify.h" 1
# 20 "src/hcode/btech/mech.notify.h"
# 1 "src/hcode/btech/mech.h" 1
# 21 "src/hcode/btech/mech.notify.h" 2
# 1 "src/db.h" 1





# 1 "src/copyright.h" 1
# 7 "src/db.h" 2
# 22 "src/hcode/btech/mech.notify.h" 2
# 30 "src/hcode/btech/mech.notify.h"
# 1 "src/hcode/btech/p.mech.notify.h" 1
# 16 "src/hcode/btech/p.mech.notify.h"
const char *GetAmmoDesc_Model_Mode(int model, int mode);
char GetWeaponAmmoModeLetter_Model_Mode(int model, int mode);
char GetWeaponFireModeLetter_Model_Mode(int model, int mode);
char GetWeaponAmmoModeLetter(MECH * mech, int loop, int crit);
char GetWeaponFireModeLetter(MECH * mech, int loop, int crit);
const char *GetMoveTypeID(int movetype);
void Mech_ShowFlags(dbref player, MECH * mech, int spaces, int level);
const char *GetArcID(MECH * mech, int arc);
const char *GetMechToMechID_base(MECH * see, MECH * mech, int i);
const char *GetMechToMechID(MECH * see, MECH * mech);
const char *GetMechID(MECH * mech);
void mech_set_channelfreq(dbref player, void *data, char *buffer);
void mech_set_channeltitle(dbref player, void *data, char *buffer);
void mech_set_channelmode(dbref player, void *data, char *buffer);
void mech_list_freqs(dbref player, void *data, char *buffer);
void mech_sendchannel(dbref player, void *data, char *buffer);
void ScrambleMessage(char *buffo, int range, int sendrange, int recvrrange,
    char *handle, char *msg, int bth, int *isxp, int under_ecm,
    int digmode);
int common_checks(dbref player, MECH * mech, int flag);
void recursive_commlink(int i, int dep);
void nonrecursive_commlink(int i);
int findCommLink(MAP * map, MECH * from, MECH * to, int freq);
void sendchannelstuff(MECH * mech, int freq, char *msg);
void mech_radio(dbref player, void *data, char *buffer);
void MechBroadcast(MECH * mech, MECH * target, MAP * mech_map,
    char *buffer);
void MechLOSBroadcast(MECH * mech, char *message);
int MechSeesHexF(MECH * mech, MAP * map, float x, float y, int ix, int iy);
int MechSeesHex(MECH * mech, MAP * map, int x, int y);
void HexLOSBroadcast(MAP * mech_map, int x, int y, char *message);
void MechLOSBroadcasti(MECH * mech, MECH * target, char *message);
void MapBroadcast(MAP * map, char *message);
void MechFireBroadcast(MECH * mech, MECH * target, int x, int y,
    MAP * mech_map, char *weapname, int IsHit);
void mech_notify(MECH * mech, int type, char *buffer);
# 31 "src/hcode/btech/mech.notify.h" 2
# 1290 "src/hcode/btech/mech.h" 2


typedef struct {
    int x;
    int y;
} lostrace_info;
# 20 "src/hcode/btech/mech.tech.commands.c" 2

# 1 "src/hcode/btech/mech.events.h" 1
# 21 "src/hcode/btech/mech.events.h"
# 1 "src/hcode/btech/mech.h" 1
# 22 "src/hcode/btech/mech.events.h" 2
# 132 "src/hcode/btech/mech.events.h"
# 1 "src/hcode/btech/p.aero.move.h" 1
# 16 "src/hcode/btech/p.aero.move.h"
void aero_takeoff(dbref player, void *data, char *buffer);
void DS_BlastNearbyMechsAndTrees(MECH * mech, char *hitmsg, char *hitmsg1,
    char *nearhitmsg, char *nearhitmsg1, char *treehitmsg, int damage);
void aero_land(dbref player, void *data, char *buffer);
void aero_ControlEffect(MECH * mech);
void ds_BridgeHit(MECH * mech);
void aero_UpdateHeading(MECH * mech);
double my_sqrt(double x, double y);
double my_sqrtm(double x, double y);
void aero_UpdateSpeed(MECH * mech);
int FuelCheck(MECH * mech);
void aero_update(MECH * mech);
void aero_thrust(dbref player, void *data, char *arg);
void aero_vheading(dbref player, void *data, char *arg, int flag);
void aero_climb(dbref player, MECH * mech, char *arg);
void aero_dive(dbref player, MECH * mech, char *arg);
int ImproperLZ(MECH * mech, int x, int y);
void DS_LandWarning(MECH * mech, int serious);
void aero_checklz(dbref player, MECH * mech, char *buffer);
# 133 "src/hcode/btech/mech.events.h" 2
# 1 "src/hcode/btech/p.mech.move.h" 1
# 16 "src/hcode/btech/p.mech.move.h"
const char *LateralDesc(MECH * mech);
void mech_lateral(dbref player, void *data, char *buffer);
void mech_bootlegger(dbref player, void *data, char *buffer);
void mech_eta(dbref player, void *data, char *buffer);
float MechCargoMaxSpeed(MECH * mech, float mspeed);
void mech_drop(dbref player, void *data, char *buffer);
void mech_stand(dbref player, void *data, char *buffer);
void mech_land(dbref player, void *data, char *buffer);
void mech_heading(dbref player, void *data, char *buffer);
void mech_turret(dbref player, void *data, char *buffer);
void mech_rotatetorso(dbref player, void *data, char *buffer);
void mech_speed(dbref player, void *data, char *buffer);
void mech_vertical(dbref player, void *data, char *buffer);
void mech_thrash(dbref player, void *data, char *buffer);
void mech_jump(dbref player, void *data, char *buffer);
void mech_hulldown(dbref player, void *data, char *buffer);

void mech_sprint(dbref player, void *data, char *buffer);
void mech_evade(dbref player, void *data, char *buffer);

void mech_dodge(dbref player, void *date, char *buffer);


int DropGetElevation(MECH * mech);
void DropSetElevation(MECH * mech, int wantdrop);
void LandMech(MECH * mech);
void MechFloodsLoc(MECH * mech, int loc, int lev);
void MechFloods(MECH * mech);
void MechFalls(MECH * mech, int levels, int seemsg);
int mechs_in_hex(MAP * map, int x, int y, int friendly, int team);
void cause_damage(MECH * att, MECH * mech, int dam, int table);
int domino_space_in_hex(MAP * map, MECH * me, int x, int y, int friendly,
    int mode, int cnt);
int domino_space(MECH * mech, int mode);
# 134 "src/hcode/btech/mech.events.h" 2
# 1 "src/hcode/btech/p.mech.events.h" 1
# 16 "src/hcode/btech/p.mech.events.h"
void mech_standfail_event(EVENT * e);
void mech_fall_event(EVENT * e);
void mech_lock_event(EVENT * e);
void mech_stabilizing_event(EVENT * e);
void mech_jump_event(EVENT * e);
void mech_recovery_event(EVENT * e);
void mech_recycle_event(EVENT * e);
void ProlongUncon(MECH * mech, int len);
void MaybeRecycle(MECH * mech, int wticks);
void mech_lateral_event(EVENT * e);
void mech_move_event(EVENT * e);
void mech_stand_event(EVENT * e);
void mech_plos_event(EVENT * e);
void aero_move_event(EVENT * e);
void very_fake_func(EVENT * e);
void unstun_crew_event(EVENT * e);
void mech_unjam_ammo_event(EVENT * objEvent);
void check_stagger_event(EVENT * event);

void mech_movemode_event(EVENT * e);

int calcStaggerBTHMod(MECH * mech);
# 135 "src/hcode/btech/mech.events.h" 2
# 22 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "src/hcode/btech/mech.tech.h" 1
# 22 "src/hcode/btech/mech.tech.h"
# 1 "src/hcode/btech/mech.events.h" 1
# 23 "src/hcode/btech/mech.tech.h" 2
# 188 "src/hcode/btech/mech.tech.h"
void tech_removegun (dbref player, void *data, char *buffer);
void tech_removepart (dbref player, void *data, char *buffer);
void tech_removesection (dbref player, void *data, char *buffer);
void tech_replacegun (dbref player, void *data, char *buffer);
void tech_repairgun (dbref player, void *data, char *buffer);
void tech_fixenhcrit (dbref player, void *data, char *buffer);
void tech_replacepart (dbref player, void *data, char *buffer);
void tech_repairpart (dbref player, void *data, char *buffer);
void tech_toggletype (dbref player, void *data, char *buffer);
void tech_reload (dbref player, void *data, char *buffer);
void tech_unload (dbref player, void *data, char *buffer);
void tech_fixarmor (dbref player, void *data, char *buffer);
void tech_fixinternal (dbref player, void *data, char *buffer);
void tech_reattach (dbref player, void *data, char *buffer);
void tech_checkstatus (dbref player, void *data, char *buffer);
void tech_reseal (dbref player, void *data, char *buffer);
void tech_replacesuit (dbref player, void *data, char *buffer);
extern void show_mechs_damage (dbref player, void *data, char *buffer);
extern void tech_fix (dbref player, void *data, char *buffer);
# 254 "src/hcode/btech/mech.tech.h"
extern void event_mech_reattach (EVENT *e);
extern void event_mech_reseal (EVENT *e);
extern void event_mech_reload (EVENT *e);
extern void event_mech_removegun (EVENT *e);
extern void event_mech_removepart (EVENT *e);
extern void event_mech_removesection (EVENT *e);
extern void event_mech_repairarmor (EVENT *e);
extern void event_mech_repairgun (EVENT *e);
extern void event_mech_repairenhcrit (EVENT *e);
extern void event_mech_repairinternal (EVENT *e);
extern void event_mech_repairpart (EVENT *e);
extern void event_mech_replacegun (EVENT *e);
extern void event_mech_mountbomb (EVENT *e);
extern void event_mech_umountbomb (EVENT *e);
extern void event_mech_replacesuit (EVENT *e);
extern void very_fake_func (EVENT *e);

void loadrepairs(FILE * f);
void saverepairs(FILE * f);
int valid_ammo_mode(MECH * mech, int loc, int part, int let);
# 23 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "src/hcode/btech/failures.h" 1
# 16 "src/hcode/btech/failures.h"
# 1 "src/hcode/btech/p.failures.h" 1
# 16 "src/hcode/btech/p.failures.h"
int GetBrandIndex(int type);
char *GetPartBrandName(int type, int level);
void FailureRadioStatic(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void FailureRadioShort(MECH * mech, int weapnum, int weaptype, int section,
    int critical, int roll, int *modifier, int *type);
void FailureRadioRange(MECH * mech, int weapnum, int weaptype, int section,
    int critical, int roll, int *modifier, int *type);
void FailureComputerShutdown(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void FailureComputerScanner(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void FailureComputerTarget(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void FailureWeaponMissiles(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void FailureWeaponDud(MECH * mech, int weapnum, int weaptype, int section,
    int critical, int roll, int *modifier, int *type);
void FailureWeaponJammed(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void FailureWeaponRange(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void FailureWeaponDamage(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void FailureWeaponHeat(MECH * mech, int weapnum, int weaptype, int section,
    int critical, int roll, int *modifier, int *type);
void FailureWeaponSpike(MECH * mech, int weapnum, int weaptype,
    int section, int critical, int roll, int *modifier, int *type);
void CheckGenericFail(MECH * mech, int type, int *result, int *mod);
void CheckWeaponFailed(MECH * mech, int weapnum, int weaptype, int section,
    int critical, int *modifier, int *type);
# 17 "src/hcode/btech/failures.h" 2
# 44 "src/hcode/btech/failures.h"
struct brand_data {
    char *name;
    short level;
    int success;
    int modifier;
};

struct failure_data {
    char *message;
    int data;
    void (*func) (MECH *, int, int, int, int, int, int *, int *);
    int type;
    int flag;
};
# 69 "src/hcode/btech/failures.h"
extern struct brand_data brands[];
extern struct failure_data failures[];
# 24 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "src/hcode/btech/p.mech.utils.h" 1
# 18 "src/hcode/btech/p.mech.utils.h"
const char *mechtypename(MECH * foo);
int MNumber(MECH * mech, int low, int high);
char *MechIDS(MECH * mech, int islower);
char *MyToUpper(char *string);
int CritsInLoc(MECH * mech, int index);
int SectHasBusyWeap(MECH * mech, int sect);
MAP *ValidMap(dbref player, dbref map);
dbref FindMechOnMap(MAP *map, char *mechid);
dbref FindTargetDBREFFromMapNumber(MECH * mech, char *mapnum);
void FindComponents(float magnitude, int degrees, float *x, float *y);
void CheckEdgeOfMap(MECH * mech);
int FindBearing(float x0, float y0, float x1, float y1);
int InWeaponArc(MECH * mech, float x, float y);
char *FindGunnerySkillName(MECH * mech, int weapindx);
char *FindPilotingSkillName(MECH * mech);
int FindPilotPiloting(MECH * mech);
int FindSPilotPiloting(MECH * mech);
int FindPilotSpotting(MECH * mech);
int FindPilotArtyGun(MECH * mech);
int FindPilotGunnery(MECH * mech, int weapindx);
char *FindTechSkillName(MECH * mech);
int FindTechSkill(dbref player, MECH * mech);
int MadePilotSkillRoll(MECH * mech, int mods);
int MechPilotSkillRoll_BTH(MECH *mech, int mods);
int MadePilotSkillRoll_Advanced(MECH * mech, int mods,
    int succeedWhenFallen);
void FindXY(float x0, float y0, int bearing, float range, float *x1,
    float *y1);
float FindRange(float x0, float y0, float z0, float x1, float y1,
    float z1);
float FindXYRange(float x0, float y0, float x1, float y1);
float FindHexRange(float x0, float y0, float x1, float y1);
void RealCoordToMapCoord(short *hex_x, short *hex_y, float cart_x,
    float cart_y);
void MapCoordToRealCoord(int hex_x, int hex_y, float *cart_x,
    float *cart_y);
void navigate_sketch_mechs(MECH *mech, MAP *map, int x, int y,
    char buff[13][400]);
int FindTargetXY(MECH * mech, float *x, float *y, float *z);
int FindWeapons_Advanced(MECH * mech, int index, unsigned char *weaparray,
    unsigned char *weapdataarray, int *critical, int whine);
int FindAmmunition(MECH * mech, unsigned char *weaparray,
    unsigned short *ammoarray, unsigned short *ammomaxarray,
    unsigned int *modearray);
int FindLegHeatSinks(MECH * mech);
int FindWeaponNumberOnMech_Advanced(MECH * mech, int number, int *section,
    int *crit, int sight);
int FindWeaponNumberOnMech(MECH * mech, int number, int *section,
    int *crit);
int FindWeaponFromIndex(MECH * mech, int weapindx, int *section,
    int *crit);
int FindWeaponIndex(MECH * mech, int number);
int findAmmoInSection(MECH * mech, int section, int type, int nogof,
    int gof);
int FindAmmoForWeapon_sub(MECH * mech, int weapSection, int weapCritical,
    int weapindx, int start, int *section, int *critical, int nogof,
    int gof);
int FindAmmoForWeapon(MECH * mech, int weapindx, int start, int *section,
    int *critical);
int CountAmmoForWeapon(MECH * mech, int weapindx);
int FindArtemisForWeapon(MECH * mech, int section, int critical);
int FindDestructiveAmmo(MECH * mech, int *section, int *critical);
int FindRoundsForWeapon(MECH * mech, int weapindx);
const char **ProperSectionStringFromType(int type, int mtype);
void ArmorStringFromIndex(int index, char *buffer, char type, char mtype);
int IsInWeaponArc(MECH * mech, float x, float y, int section,
    int critical);
int GetWeaponCrits(MECH * mech, int weapindx);
int listmatch(char **foo, char *mat);
void do_sub_magic(MECH * mech, int loud);
void do_magic(MECH * mech);
void mech_RepairPart(MECH * mech, int loc, int pos);
int no_locations_destroyed(MECH * mech);
void mech_ReAttach(MECH * mech, int loc);
void mech_ReplaceSuit(MECH * mech, int loc);
void mech_ReSeal(MECH * mech, int loc);
void mech_Detach(MECH * mech, int loc);
void mech_FillPartAmmo(MECH * mech, int loc, int pos);
int AcceptableDegree(int d);
void MarkForLOSUpdate(MECH * mech);
void multi_weap_sel(MECH * mech, dbref player, char *buffer, int bitbybit,
    int (*foo) (MECH *, dbref, int, int));
int Roll(void);
int MyHexDist(int x1, int y1, int x2, int y2, int tc);
int CountDestroyedLegs(MECH * objMech);
int IsLegDestroyed(MECH * objMech, int wLoc);
int IsMechLegLess(MECH * objMech);
int FindFirstWeaponCrit(MECH * objMech, int wLoc, int wSlot,
    int wStartSlot, int wCritType, int wMaxCrits);
int checkAllSections(MECH * mech, int specialToFind);
int checkSectionForSpecial(MECH * mech, int specialToFind, int wSec);

int getRemainingInternalPercent(MECH * mech);
int getRemainingArmorPercent(MECH * mech);
int FindObj(MECH * mech, int loc, int type);
int FindObjWithDest(MECH * mech, int loc, int type);
MECH *find_mech_in_hex(MECH * mech, MAP * mech_map, int x, int y,
    int needlos);
int FindAndCheckAmmo(MECH * mech, int weapindx, int section, int critical,
    int *ammoLoc, int *ammoCrit, int *ammoLoc1, int *ammoCrit1,
    int *wGattlingShots);
void ChannelEmitKill(MECH * mech, MECH * attacker);
void visit_neighbor_hexes(MAP *map, int x, int y,
    void (*callback)(MAP *, int, int));
int GetPartWeight(int part);

unsigned long long int GetPartCost(int p);
void SetPartCost(int p, unsigned long long int cost);
unsigned long long int CalcFasaCost(MECH * mech);


int FindAverageGunnery(MECH * mech);
int CalculateBV(MECH *mech, int gunstat, int pilstat);


int MechFullNoRecycle(MECH * mech, int num);
# 25 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "src/hcode/btech/p.mech.tech.h" 1
# 16 "src/hcode/btech/p.mech.tech.h"
int game_lag(void);
int game_lag_time(int i);
int tech_roll(dbref player, MECH * mech, int diff);
int tech_weapon_roll(dbref player, MECH * mech, int diff);
void tech_status(dbref player, time_t dat);
int tech_addtechtime(dbref player, int time);
int tech_parsepart_advanced(MECH * mech, char *buffer, int *loc, int *pos,
    int *extra, int allowrear);
int tech_parsepart(MECH * mech, char *buffer, int *loc, int *pos,
    int *extra);
int tech_parsegun(MECH * mech, char *buffer, int *loc, int *pos,
    int *brand);
int figure_latest_tech_event(MECH * mech);
# 26 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "src/hcode/btech/p.mech.consistency.h" 1
# 19 "src/hcode/btech/p.mech.consistency.h"
int susp_factor(MECH * mech);

int engine_weight(MECH * mech);
int mech_weight_sub_mech(dbref player, MECH * mech, int interactive);
int mech_weight_sub_veh(dbref player, MECH * mech, int interactive);
int mech_weight_sub(dbref player, MECH * mech, int interactive);
void mech_weight(dbref player, void *data, char *buffer);
void vehicle_int_check(MECH * mech, int noisy);
void mech_int_check(MECH * mech, int noisy);
# 27 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "src/hcode/btech/p.mech.tech.do.h" 1
# 16 "src/hcode/btech/p.mech.tech.do.h"
int valid_ammo_mode(MECH * mech, int loc, int part, int let);
int FindAmmoType(MECH * mech, int loc, int part);
int replace_econ(dbref player, MECH * mech, int loc, int part);
int reload_econ(dbref player, MECH * mech, int loc, int part, int *val);
int fixarmor_econ(dbref player, MECH * mech, int loc, int *val);
int fixinternal_econ(dbref player, MECH * mech, int loc, int *val);
int repair_econ(dbref player, MECH * mech, int loc, int part);
int repairenhcrit_econ(dbref player, MECH * mech, int loc, int part);
int reattach_econ(dbref player, MECH * mech, int loc);
int replacesuit_econ(dbref player, MECH * mech, int loc);
int reseal_econ(dbref player, MECH * mech, int loc);
int replacep_succ(dbref player, MECH * mech, int loc, int part);
int replaceg_succ(dbref player, MECH * mech, int loc, int part);
int reload_succ(dbref player, MECH * mech, int loc, int part, int *val);
int fixinternal_succ(dbref player, MECH * mech, int loc, int *val);
int fixarmor_succ(dbref player, MECH * mech, int loc, int *val);
int reattach_succ(dbref player, MECH * mech, int loc);
int replacesuit_succ(dbref player, MECH * mech, int loc);
int reseal_succ(dbref player, MECH * mech, int loc);
int repairg_succ(dbref player, MECH * mech, int loc, int part);
int repairenhcrit_succ(dbref player, MECH * mech, int loc, int part);
int repairp_succ(dbref player, MECH * mech, int loc, int part);
int replacep_fail(dbref player, MECH * mech, int loc, int part);
int repairp_fail(dbref player, MECH * mech, int loc, int part);
int replaceg_fail(dbref player, MECH * mech, int loc, int part);
int repairg_fail(dbref player, MECH * mech, int loc, int part);
int repairenhcrit_fail(dbref player, MECH * mech, int loc, int part);
int reload_fail(dbref player, MECH * mech, int loc, int part, int *val);
int fixarmor_fail(dbref player, MECH * mech, int loc, int *val);
int fixinternal_fail(dbref player, MECH * mech, int loc, int *val);
int reattach_fail(dbref player, MECH * mech, int loc);
int replacesuit_fail(dbref player, MECH * mech, int loc);
int reseal_fail(dbref player, MECH * mech, int loc);
# 28 "src/hcode/btech/mech.tech.commands.c" 2
# 1 "src/hcode/btech/p.bsuit.h" 1
# 16 "src/hcode/btech/p.bsuit.h"
char *GetBSuitName(MECH * mech);
char *GetLCaseBSuitName(MECH * mech);
void StartBSuitRecycle(MECH * mech, int time);
void StopSwarming(MECH * mech, int intentional);
int CountSwarmers(MECH * mech);
MECH *findSwarmers(MECH * mech);
void StopBSuitSwarmers(MAP * map, MECH * mech, int intentional);
int IsMechSwarmed(MECH * mech);
int IsMechMounted(MECH * mech);
void BSuitMirrorSwarmedTarget(MAP * map, MECH * mech);
int doBSuitCommonChecks(MECH * mech, dbref player);
int CountBSuitMembers(MECH * mech);
int FindBSuitTarget(dbref player, MECH * mech, MECH ** target,
    char *buffer);
int doJettisonChecks(MECH * mech);
void bsuit_swarm(dbref player, void *data, char *buffer);
void bsuit_attackleg(dbref player, void *data, char *buffer);
void bsuit_hide(dbref player, void *data, char *buffer);
void JettisonPacks(dbref player, void *data, char *buffer);
# 29 "src/hcode/btech/mech.tech.commands.c" 2
# 50 "src/hcode/btech/mech.tech.commands.c"
static int tmp_flag = 0;
static int tmp_loc;
static int tmp_part;

static void tech_check_locpart(EVENT * e)
{
    int loc, pos;
    int l = (int) e->data2;

    loc = (l % 16);pos = (l / 16) % 16;
    if (loc == tmp_loc && pos == tmp_part)
 tmp_flag++;
}

static void tech_check_loc(EVENT * e)
{
    int loc;

    loc = (((int) e->data2) % 16);
    if (loc == tmp_loc)
 tmp_flag++;
}
# 91 "src/hcode/btech/mech.tech.commands.c"
int SomeoneRepairing_s(MECH * mech, int loc, int part, int t)
{
    tmp_flag=0;tmp_loc=loc;tmp_part = part; muxevent_gothru_type_data(t, (void *) mech, tech_check_locpart); return tmp_flag;
}




int SomeoneRepairing(MECH * mech, int loc, int part)
{
    if (SomeoneRepairing_s(mech, loc, part, (40 +3))) return 1;
    if (SomeoneRepairing_s(mech, loc, part, 40)) return 1;
    if (SomeoneRepairing_s(mech, loc, part, (40 +1))) return 1;
    if (SomeoneRepairing_s(mech, loc, part, (40 +10))) return 1;
    if (SomeoneRepairing_s(mech, loc, part, (40 +9))) return 1;
    if (SomeoneRepairing_s(mech, loc, part, (40 +11))) return 1;
    if (SomeoneRepairing_s(mech, loc, part, (40 +15))) return 1;
    return 0;
}


int SomeoneFixingA(MECH * mech, int loc)
{
    tmp_flag=0;tmp_loc=loc; muxevent_gothru_type_data((40 +4), (void *) mech, tech_check_loc); return tmp_flag;
}

int SomeoneFixingI(MECH * mech, int loc)
{
    tmp_flag=0;tmp_loc=loc; muxevent_gothru_type_data((40 +5), (void *) mech, tech_check_loc); return tmp_flag;
}

int SomeoneFixing(MECH * mech, int loc)
{
    return SomeoneFixingA(mech, loc) || SomeoneFixingI(mech, loc);
}


int SomeoneAttaching(MECH * mech, int loc)
{
    tmp_flag=0;tmp_loc=loc; muxevent_gothru_type_data((40 +2), (void *) mech, tech_check_loc); return tmp_flag;
}

int SomeoneReplacingSuit(MECH * mech, int loc)
{
    tmp_flag=0;tmp_loc=loc; muxevent_gothru_type_data((40 +14), (void *) mech, tech_check_loc); return tmp_flag;
}







int SomeoneResealing(MECH * mech, int loc)
{
    tmp_flag=0;tmp_loc=loc; muxevent_gothru_type_data((40 +13), (void *) mech, tech_check_loc); return tmp_flag;
}

int SomeoneScrappingLoc(MECH * mech, int loc)
{
    tmp_flag=0;tmp_loc=loc; muxevent_gothru_type_data((40 +6), (void *) mech, tech_check_loc); return tmp_flag;
}

int SomeoneScrappingPart(MECH * mech, int loc, int part)
{
    if (SomeoneRepairing_s(mech, loc, part, (40 +7))) return 1;
    if (SomeoneRepairing_s(mech, loc, part, (40 +8))) return 1;
    if (SomeoneRepairing_s(mech, loc, part, (40 +12))) return 1;
    return 0;
}





int CanScrapLoc(MECH * mech, int loc)
{
    tmp_flag = 0;
    tmp_loc = loc % 8;
    muxevent_gothru_type_data(40, (void *) mech,
 tech_check_loc);
    muxevent_gothru_type_data((40 +3), (void *) mech,
 tech_check_loc);
    return !tmp_flag && !SomeoneFixing(mech, loc);
}

int CanScrapPart(MECH * mech, int loc, int part)
{
    return !(SomeoneRepairing(mech, loc, part));
}



extern char *silly_get_uptime_to_string(int);

int ValidGunPos(MECH * mech, int loc, int pos)
{
    unsigned char weaparray_f[12];
    unsigned char weapdata_f[12];
    int critical_f[12];
    int i, num_weaps_f;

    if ((num_weaps_f =
     FindWeapons_Advanced(mech, loc, weaparray_f, weapdata_f,
  critical_f, 1)) < 0)
 return 0;
    for (i = 0; i < num_weaps_f; i++)
 if (critical_f[i] == pos)
     return 1;
    return 0;
}

void tech_checkstatus(dbref player, void *data, char *buffer)
{
    MECH *mech = (MECH *) data;
    int i = figure_latest_tech_event(mech);
    char *ms;

    if (!i) { mecha_notify(player,"The mech's ready to rock!"); return; };
    ms = silly_get_uptime_to_string(game_lag_time(i));
    mecha_notify(player,tprintf("The 'mech has approximately %s until done.", ms));

}

void tech_removegun (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;
    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsegun(mech, buffer, &loc, &part, ((void *)0))) { case -1: mecha_notify(player,"Invalid gun #!");return; case -2: mecha_notify(player,"Invalid object to replace with!");return; case -3: mecha_notify(player,"Invalid object type - not matching with original.");return; case -4: mecha_notify(player,"Invalid gun location - subscript out of range.");return; };
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! You can assume the gun's gone too!"); return; };

    if (!(((mech)->ud.sections[loc].criticals[part].type) >= 1 && ((mech)->ud.sections[loc].criticals[part].type) < (1 + 192))) { mecha_notify(player,"That's no gun!"); return; };
    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001)) { mecha_notify(player,"That gun's gone already!"); return; };
    if (!ValidGunPos(mech, loc, part)) { mecha_notify(player,"You can't remove middle of a gun!"); return; };

    if (SomeoneScrappingPart(mech, loc, part)) { mecha_notify(player,"Someone's scrapping it already!"); return; };

    if (!CanScrapPart(mech, loc, part)) { mecha_notify(player,"Someone's tinkering with it already!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no additional removals are possible!"); return; };


    if (tech_weapon_roll(player, mech, 1) < 0) {
 mecha_notify(player,"Ack! Your attempt is far from perfect, you try to recover the gun..");

 if (tech_weapon_roll(player, mech, 1) < 0) {
     mecha_notify(player,"No good. Consider the part gone.");
     muxevent_add(MAX(1, tech_addtechtime(player, (40 * MAX(1, (((GetWeaponCrits(mech, (((mech)->ud.sections[loc].criticals[part].type) - 1))) / (((mech)->rd.specials & 0x20) ? 2 : 1)))) * mod) / 2)), 0, (40 +8), very_fake_func, (void *) mech, (void *) ((((loc) + (part)*16 + (mod)*16*16)) + player * (16*16*256));


     mod = 3;
     return;
 }
    }
    mecha_notify(player,"You start removing the gun..");
    muxevent_add(MAX(1, tech_addtechtime(player, (40 * MAX(1, (((GetWeaponCrits(mech, (((mech)->ud.sections[loc].criticals[part].type) - 1))) / (((mech)->rd.specials & 0x20) ? 2 : 1)))) * mod) / 2)), 0, (40 +8), event_mech_removegun, (void *) mech, (void *) ((((loc) + (part)*16 + (mod)*16*16)) + player * (16*16*256));



}


void tech_removepart (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;
    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, &part,((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if ((t = (mech)->ud.sections[loc].criticals[part].type) == 0) { mecha_notify(player,"That location is empty!"); return; };


    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! You can assume the part's gone too!"); return; };

    if (((t) >= 1 && (t) < (1 + 192))) { mecha_notify(player,"That's a gun - use removegun instead!"); return; };
    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001)) { mecha_notify(player,"That part's gone already!"); return; };
    if (((((mech)->ud.sections[loc].criticals[part].type) == ((13) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((12) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((14) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((34) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((38) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((39) + (((1 + 192) + 192) + 9))))) { mecha_notify(player,"That type isn't scrappable!"); return; };

    if (t == ((13) + (((1 + 192) + 192) + 9)) || t == ((12) + (((1 + 192) + 192) + 9)) || t == ((34) + (((1 + 192) + 192) + 9)) || t == ((38) + (((1 + 192) + 192) + 9)) || t == ((39) + (((1 + 192) + 192) + 9))) { mecha_notify(player,"That type of item can't be removed!"); return; };



    if (SomeoneScrappingPart(mech, loc, part)) { mecha_notify(player,"Someone's scrapping it already!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no additional removals are possible!"); return; };

    if (!CanScrapPart(mech, loc, part)) { mecha_notify(player,"Someone's tinkering with it already!"); return; };


    mecha_notify(player,"You start removing the part..");
    if (tech_roll(player, mech, 0) < 0) {
 mecha_notify(player,"Ack! Your attempt is far from perfect, you try to recover the part..");

 if (tech_roll(player, mech, 0) < 0) {
     mecha_notify(player,"No good. Consider the part gone.");
     mod = 3;
     muxevent_add(MAX(1, tech_addtechtime(player, (40 * mod) / 2)), 0, (40 +7), very_fake_func, (void *) mech, (void *) ((((loc) + (part)*16 + (mod)*16*16)) + player * (16*16*256));

     return;
 }
    }
    muxevent_add(MAX(1, tech_addtechtime(player, (40 * mod) / 2)), 0, (40 +7), event_mech_removepart, (void *) mech, (void *) ((((loc) + (part)*16 + (mod)*16*16)) + player * (16*16*256));

}
# 301 "src/hcode/btech/mech.tech.commands.c"
int Invalid_Scrap_Path(MECH * mech, int loc)
{
    if (loc < 0)
 return 0;
    if ((mech)->ud.type != 0)
 return 0;
    switch (loc) {
 case 4: if (!(!((mech)->ud.sections[7].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[7].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) return 1; if (Invalid_Scrap_Path(mech,7)) return 1;
 if (!(!((mech)->ud.sections[2].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[2].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) return 1; if (Invalid_Scrap_Path(mech,2)) return 1;
 if (!(!((mech)->ud.sections[3].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[3].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) return 1; if (Invalid_Scrap_Path(mech,3)) return 1;
 break;
 case 2: if (!(!((mech)->ud.sections[0].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[0].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) return 1; if (Invalid_Scrap_Path(mech,0)) return 1;
 break;
 case 3: if (!(!((mech)->ud.sections[1].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[1].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) return 1; if (Invalid_Scrap_Path(mech,1)) return 1;
 break;
    }
    return 0;
}




void tech_removesection (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;
    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, ((void *)0),((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That section's gone already!"); return; };
    if (Invalid_Scrap_Path(mech, loc)) { mecha_notify(player,"You need to remove the outer sections first!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping it already!"); return; };

    if (!CanScrapLoc(mech, loc)) { mecha_notify(player,"Someone's tinkering with it already!"); return; };


    if (tech_roll(player, mech, 2) < 0)
 mod = 3;
    mecha_notify(player,"You start removing the section..");
    muxevent_add(MAX(1, tech_addtechtime(player, (120 * mod) / 2)), 0, (40 +6), event_mech_removesection, (void *) mech, (void *) ((((loc) + (0)*16 + (mod)*16*16)) + player * (16*16*256));

}


void tech_replacegun (dbref player, void * data, char * buffer)
{
    int brand = 0, ob = 0;

    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;
    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsegun(mech, buffer, &loc, &part, &brand)) { case -1: mecha_notify(player,"Invalid gun #!");return; case -2: mecha_notify(player,"Invalid object to replace with!");return; case -3: mecha_notify(player,"Invalid object type - not matching with original.");return; case -4: mecha_notify(player,"Invalid gun location - subscript out of range.");return; };
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneRepairing(mech, loc, part)) { mecha_notify(player,"Someone's repairing that part already!"); return; };

    if (!(((mech)->ud.sections[loc].criticals[part].type) >= 1 && ((mech)->ud.sections[loc].criticals[part].type) < (1 + 192))) { mecha_notify(player,"That's no gun!"); return; };
    if (!ValidGunPos(mech, loc, part)) { mecha_notify(player,"You can't replace middle of a gun!"); return; };

    if (!(((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002) || ((mech)->ud.sections[loc].criticals[part].firemode & (0x00000001|0x00000004)) || ((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001))) { mecha_notify(player,"That gun isn't hurtin'!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    if (brand) {
 ob = ((mech)->ud.sections[loc].criticals[part].brand%16);
 (mech)->ud.sections[loc].criticals[part].brand = (brand) + (((mech)->ud.sections[loc].criticals[part].brand>>4)<<4);
    }
    if (replace_econ(player,mech,loc,part)>=0) { mecha_notify(player,"You start replacing the gun.."); if ((!1 && tech_roll(player, mech, 1 + ((int) (sqrt(MechWeapons[(((mech)->ud.sections[loc].criticals[part].type) - 1)].criticals)*1.5-1.1))) < 0) || (1 && tech_weapon_roll(player, mech, 1 + ((int) (sqrt(MechWeapons[(((mech)->ud.sections[loc].criticals[part].type) - 1)].criticals)*1.5-1.1))) < 0)) { mod = 3; if (replaceg_fail(player,mech,loc,part)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (60 * MAX(1, (((GetWeaponCrits(mech, (((mech)->ud.sections[loc].criticals[part].type) - 1))) / (((mech)->rd.specials & 0x20) ? 2 : 1)))) * mod) / 2)), 0, (40 +1), very_fake_func, (void *) mech, (void *) ((((loc) + (part)*16 + (brand)*16*16)) + player * (16*16*256)); return;}} else { if (replaceg_succ(player,mech,loc,part)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (60 * MAX(1, (((GetWeaponCrits(mech, (((mech)->ud.sections[loc].criticals[part].type) - 1))) / (((mech)->rd.specials & 0x20) ? 2 : 1)))) * mod) / 2)), 0, (40 +1), event_mech_replacegun, (void *) mech, (void *) ((((loc) + (part)*16 + (brand)*16*16)) + player * (16*16*256)); };






    if (brand)
 (mech)->ud.sections[loc].criticals[part].brand = (ob) + (((mech)->ud.sections[loc].criticals[part].brand>>4)<<4);
}

void tech_repairgun (dbref player, void * data, char * buffer)
{
    int extra_hard = 0;

    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;
    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;

    switch (tech_parsegun(mech, buffer, &loc, &part, ((void *)0))) { case -1: mecha_notify(player,"Invalid gun #!");return; case -2: mecha_notify(player,"Invalid object to replace with!");return; case -3: mecha_notify(player,"Invalid object type - not matching with original.");return; case -4: mecha_notify(player,"Invalid gun location - subscript out of range.");return; };
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneRepairing(mech, loc, part)) { mecha_notify(player,"Someone's repairing that part already!"); return; };

    if (!(((mech)->ud.sections[loc].criticals[part].type) >= 1 && ((mech)->ud.sections[loc].criticals[part].type) < (1 + 192))) { mecha_notify(player,"That's no gun!"); return; };
    if (!ValidGunPos(mech, loc, part)) { mecha_notify(player,"You can't repair middle of a gun!"); return; };

    if (SomeoneScrappingPart(mech, loc, part)) { mecha_notify(player,"Someone's scrapping it already!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002)) { mecha_notify(player,"That gun can't be fixed yet!"); return; };


    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001)) {
 if (GetWeaponCrits(mech, (((mech)->ud.sections[loc].criticals[part].type) - 1)) < 5 ||

     ((mech)->ud.sections[loc].criticals[part + 1].firemode & 0x00000001)) {
     mecha_notify(player,"That gun is gone for good!");
     return;
 }
 extra_hard = 1;
    } else if (!((mech)->ud.sections[loc].criticals[part].brand>>4)) {
 mecha_notify(player,"That gun isn't hurtin'!");
 return;
    }

    if (repair_econ(player,mech,loc,part)>=0) { mecha_notify(player,"You start repairing the weapon.."); if ((!1 && tech_roll(player, mech, 0 + ((int) (sqrt(MechWeapons[(((mech)->ud.sections[loc].criticals[part].type) - 1)].criticals)*1.5-1.1)) + extra_hard) < 0) || (1 && tech_weapon_roll(player, mech, 0 + ((int) (sqrt(MechWeapons[(((mech)->ud.sections[loc].criticals[part].type) - 1)].criticals)*1.5-1.1)) + extra_hard) < 0)) { mod = 3; if (repairg_fail(player,mech,loc,part)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (20 * mod) / 2)), 0, (40 +10), very_fake_func, (void *) mech, (void *) ((((loc) + (part)*16)) + player * (16*16*256)); return;}} else { if (repairg_succ(player,mech,loc,part)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (20 * mod) / 2)), 0, (40 +10), event_mech_repairgun, (void *) mech, (void *) ((((loc) + (part)*16)) + player * (16*16*256)); };




}

void tech_fixenhcrit (dbref player, void * data, char * buffer)
{
    int extra_hard = 0;

    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;
    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;

    switch (tech_parsegun(mech, buffer, &loc, &part, ((void *)0))) { case -1: mecha_notify(player,"Invalid gun #!");return; case -2: mecha_notify(player,"Invalid object to replace with!");return; case -3: mecha_notify(player,"Invalid object type - not matching with original.");return; case -4: mecha_notify(player,"Invalid gun location - subscript out of range.");return; };
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneRepairing(mech, loc, part)) { mecha_notify(player,"Someone's repairing that part already!"); return; };

    if (!(((mech)->ud.sections[loc].criticals[part].type) >= 1 && ((mech)->ud.sections[loc].criticals[part].type) < (1 + 192))) { mecha_notify(player,"That's no gun!"); return; };
    if (SomeoneScrappingPart(mech, loc, part)) { mecha_notify(player,"Someone's scrapping it already!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002)) { mecha_notify(player,"That gun can't be fixed yet!"); return; };


    if (!((mech)->ud.sections[loc].criticals[part].firemode & 0x00000008)) {
 mecha_notify(player,"That gun isn't damaged!");
 return;
    }

    if (repairenhcrit_econ(player,mech,loc,part)>=0) { mecha_notify(player,"You start repairing the weapon..."); if ((!1 && tech_roll(player, mech, 0) < 0) || (1 && tech_weapon_roll(player, mech, 0) < 0)) { mod = 3; if (repairenhcrit_fail(player,mech,loc,part)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (15 * mod) / 2)), 0, (40 +15), very_fake_func, (void *) mech, (void *) ((((loc) + (part)*16)) + player * (16*16*256)); return;}} else { if (repairenhcrit_succ(player,mech,loc,part)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (15 * mod) / 2)), 0, (40 +15), event_mech_repairenhcrit, (void *) mech, (void *) ((((loc) + (part)*16)) + player * (16*16*256)); };
# 459 "src/hcode/btech/mech.tech.commands.c"
}

void tech_replacepart (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, &part,((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if ((t = (mech)->ud.sections[loc].criticals[part].type) == 0) { mecha_notify(player,"That location is empty!"); return; };


    if (!(((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002) || ((mech)->ud.sections[loc].criticals[part].firemode & (0x00000001|0x00000004)) || ((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001))) { mecha_notify(player,"That part looks ok to me.."); return; };

    if (((((mech)->ud.sections[loc].criticals[part].type) == ((13) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((12) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((14) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((34) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((38) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((39) + (((1 + 192) + 192) + 9))))) { mecha_notify(player,"That part isn't hurtin'!"); return; };

    if (((t) >= 1 && (t) < (1 + 192))) { mecha_notify(player,"That's a weapon! Use replacegun instead."); return; };
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneRepairing(mech, loc, part)) { mecha_notify(player,"Someone's repairing that part already!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    if (replace_econ(player,mech,loc,part)>=0) { mecha_notify(player,"You start replacing the part.."); if ((!0 && tech_roll(player, mech, 1 + (1)) < 0) || (0 && tech_weapon_roll(player, mech, 1 + (1)) < 0)) { mod = 3; if (replacep_fail(player,mech,loc,part)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (45 * mod) / 2)), 0, 40, very_fake_func, (void *) mech, (void *) ((((loc) + (part)*16)) + player * (16*16*256)); return;}} else { if (replacep_succ(player,mech,loc,part)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (45 * mod) / 2)), 0, 40, event_mech_repairpart, (void *) mech, (void *) ((((loc) + (part)*16)) + player * (16*16*256)); };




}

void tech_repairpart (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, &part,((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if ((t = (mech)->ud.sections[loc].criticals[part].type) == 0) { mecha_notify(player,"That location is empty!"); return; };


    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001)) { mecha_notify(player,"That part is gone for good!"); return; };

    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002)) { mecha_notify(player,"That part can't be repaired yet!"); return; };

    if (!((mech)->ud.sections[loc].criticals[part].brand>>4)) { mecha_notify(player,"That part isn't hurtin'!"); return; };
    if (((((mech)->ud.sections[loc].criticals[part].type) == ((13) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((12) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((14) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((34) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((38) + (((1 + 192) + 192) + 9))) || (((mech)->ud.sections[loc].criticals[part].type) == ((39) + (((1 + 192) + 192) + 9))))) { mecha_notify(player,"That part isn't hurtin'!"); return; };

    if (((t) >= 1 && (t) < (1 + 192))) { mecha_notify(player,"That's a weapon! Use repairgun instead."); return; };
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneRepairing(mech, loc, part)) { mecha_notify(player,"Someone's repairing that part already!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    if (repair_econ(player,mech,loc,part)>=0) { mecha_notify(player,"You start repairing the part.."); if ((!0 && tech_roll(player, mech, 0 + (1)) < 0) || (0 && tech_weapon_roll(player, mech, 0 + (1)) < 0)) { mod = 3; if (repairp_fail(player,mech,loc,part)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (15 * mod) / 2)), 0, (40 +10), very_fake_func, (void *) mech, (void *) ((((loc) + (part)*16)) + player * (16*16*256)); return;}} else { if (repairp_succ(player,mech,loc,part)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (15 * mod) / 2)), 0, (40 +10), event_mech_repairpart, (void *) mech, (void *) ((((loc) + (part)*16)) + player * (16*16*256)); };




}

void tech_toggletype (dbref player, void * data, char * buffer)
{
    int atype;

    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if ((!((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner))))) && ((db[mech->mynum].flags2 & 0x00100000) != 0)) { mecha_notify(player,"This command only works in simpods!"); return; };

    switch (tech_parsepart(mech, buffer, &loc, &part,&atype)) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if (!(((t = (mech)->ud.sections[loc].criticals[part].type)) >= (1 + 192) && ((t = (mech)->ud.sections[loc].criticals[part].type)) < ((1 + 192) + 192))) { mecha_notify(player,"That's no ammo!"); return; };

    if ((((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002) || ((mech)->ud.sections[loc].criticals[part].firemode & (0x00000001|0x00000004)) || ((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001)) || ((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002)) { mecha_notify(player,"The ammo compartment is nonfunctional!"); return; };


    if (!atype) { mecha_notify(player,"You need to give a type to toggle to (use - for normal)"); return; };

    if ((t = (valid_ammo_mode(mech, loc, part, atype))) < 0) { mecha_notify(player,"That is invalid ammo type for this weapon!"); return; };


    (mech)->ud.sections[loc].criticals[part].ammomode &= ~((0x00000001|(0x00002000|0x00004000|0x00008000|0x00010000)|(0x00000002|0x00000004|0x00000040|0x00000080|0x00000100)|(0x00000200|0x00000400|0x00000800|0x00001000)|(0x00000008|0x00000010|0x00000020)));
    (mech)->ud.sections[loc].criticals[part].ammomode |= t;
    (mech)->ud.sections[loc].criticals[part].data=( MechWeapons[(((mech)->ud.sections[loc].criticals[part].type) - (1 + 192))].ammoperton / (3 - ((!(((mech)->ud.sections[loc].criticals[part].type) >= (1 + 192) && ((mech)->ud.sections[loc].criticals[part].type) < ((1 + 192) + 192)) || (mech)->ud.sections[loc].criticals[part].firemode & 0x00000080 || (mech)->ud.sections[loc].criticals[part].ammomode & 0x00002000 || (mech)->ud.sections[loc].criticals[part].ammomode & 0x00010000) ? 1 : 2)));
    mech_notify(mech, 2, "Ammo toggled.");
}



void tech_reload (dbref player, void * data, char * buffer)
{
    int atype;

    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;
    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (mudconf.btech_limitedrepairs && !isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, &part,&atype)) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if (!(((t = (mech)->ud.sections[loc].criticals[part].type)) >= (1 + 192) && ((t = (mech)->ud.sections[loc].criticals[part].type)) < ((1 + 192) + 192))) { mecha_notify(player,"That's no ammo!"); return; };

    if ((((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002) || ((mech)->ud.sections[loc].criticals[part].firemode & (0x00000001|0x00000004)) || ((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001))) { mecha_notify(player,"The ammo compartment is destroyed ; repair/replacepart it first."); return; };

    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002)) { mecha_notify(player,"The ammo compartment is disabled ; repair/replacepart it first."); return; };

    if ((now = (mech)->ud.sections[loc].criticals[part].data) == (full = ( MechWeapons[(((mech)->ud.sections[loc].criticals[part].type) - (1 + 192))].ammoperton / (3 - ((!(((mech)->ud.sections[loc].criticals[part].type) >= (1 + 192) && ((mech)->ud.sections[loc].criticals[part].type) < ((1 + 192) + 192)) || (mech)->ud.sections[loc].criticals[part].firemode & 0x00000080 || (mech)->ud.sections[loc].criticals[part].ammomode & 0x00002000 || (mech)->ud.sections[loc].criticals[part].ammomode & 0x00010000) ? 1 : 2))))) { mecha_notify(player,"That particular ammo compartment doesn't need reloading."); return; };


    if (SomeoneRepairing(mech, loc, part)) { mecha_notify(player,"Someone's playing with that part already!"); return; };

    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    if (atype) {
 if ((t = (valid_ammo_mode(mech, loc, part, atype))) < 0) { mecha_notify(player,"That is invalid ammo type for this weapon!"); return; };


 (mech)->ud.sections[loc].criticals[part].data=0;
 (mech)->ud.sections[loc].criticals[part].ammomode &= ~((0x00000001|(0x00002000|0x00004000|0x00008000|0x00010000)|(0x00000002|0x00000004|0x00000040|0x00000080|0x00000100)|(0x00000200|0x00000400|0x00000800|0x00001000)|(0x00000008|0x00000010|0x00000020)));
 (mech)->ud.sections[loc].criticals[part].ammomode |= t;
    }
    change = 0;
    if (reload_econ(player,mech,loc,part,&change)<0) return; mecha_notify(player,"You start reloading the ammo compartment.."); if (tech_roll(player, mech, 1) < 0) { mod = 3; if (reload_fail(player,mech,loc,part,&change)<0) {muxevent_add(MAX(1, tech_addtechtime(player, (10 * mod) / 2)), 0, (40 +3), very_fake_func, (void *) mech, (void *) ((((loc) + (part)*16 + (change)*16*16)) + player * (16*16*256));return;}} else { if (reload_succ(player,mech,loc,part,&change)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (10 * mod) / 2)), 0, (40 +3), event_mech_reload, (void *) mech, (void *) ((((loc) + (part)*16 + (change)*16*16)) + player * (16*16*256));



}

void tech_unload (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (mudconf.btech_limitedrepairs && !isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, &part,((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if (!(((t = (mech)->ud.sections[loc].criticals[part].type)) >= (1 + 192) && ((t = (mech)->ud.sections[loc].criticals[part].type)) < ((1 + 192) + 192))) { mecha_notify(player,"That's no ammo!"); return; };

    if ((((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002) || ((mech)->ud.sections[loc].criticals[part].firemode & (0x00000001|0x00000004)) || ((mech)->ud.sections[loc].criticals[part].firemode & 0x00000001))) { mecha_notify(player,"The ammo compartment is destroyed ; repair/replacepart it first."); return; };

    if (((mech)->ud.sections[loc].criticals[part].firemode & 0x00000002)) { mecha_notify(player,"The ammo compartment is disabled ; repair/replacepart it first."); return; };

    if (!(now = (mech)->ud.sections[loc].criticals[part].data)) { mecha_notify(player,"That particular ammo compartment is empty already."); return; };


    if (SomeoneRepairing(mech, loc, part)) { mecha_notify(player,"Someone's playing with that part already!"); return; };

    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    if ((full = ( MechWeapons[(((mech)->ud.sections[loc].criticals[part].type) - (1 + 192))].ammoperton / (3 - ((!(((mech)->ud.sections[loc].criticals[part].type) >= (1 + 192) && ((mech)->ud.sections[loc].criticals[part].type) < ((1 + 192) + 192)) || (mech)->ud.sections[loc].criticals[part].firemode & 0x00000080 || (mech)->ud.sections[loc].criticals[part].ammomode & 0x00002000 || (mech)->ud.sections[loc].criticals[part].ammomode & 0x00010000) ? 1 : 2)))) == now)
 change = 2;
    else
 change = 1;
    if (tech_roll(player, mech, 2) < 0)
 mod = 3;
    mecha_notify(player,"You start unloading the ammo compartment..");
    muxevent_add(MAX(1, tech_addtechtime(player, (10 * mod) / 2)), 0, (40 +3), event_mech_reload, (void *) mech, (void *) ((((loc) + (part)*16 + (change)*16*16)) + player * (16*16*256));

}

void tech_fixarmor (dbref player, void * data, char * buffer)
{
    int ochange;

    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (mudconf.btech_limitedrepairs && !isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    if (tech_parsepart_advanced(mech, buffer, &loc, ((void *)0), ((void *)0), 1) < 0) { mecha_notify(player,"Invalid section!"); return; };

    if (loc >= 8) {
 from = ((mech)->ud.sections[loc % 8].rear);
 to = (mech)->ud.sections[loc % 8].rear_orig;
    } else {
 from = ((mech)->ud.sections[loc].armor);
 to = (mech)->ud.sections[loc].armor_orig;
    }
    if ((!((mech)->ud.sections[loc % 8].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc % 8].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc % 8].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneFixingA(mech, loc) || SomeoneFixingI(mech, loc % 8)) { mecha_notify(player,"Someone's repairing that section already!"); return; };


    if (((mech)->ud.sections[loc % 8].internal) != (mech)->ud.sections[loc % 8].internal_orig) { mecha_notify(player,"The internals need to be fixed first!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    from = MIN(to, from);
    if (from == to) { mecha_notify(player,"The location doesn't need armor repair!"); return; };
    change = to - from;
    ochange = change;
    if (fixarmor_econ(player,mech,loc,&change)<0) return; mecha_notify(player,"You start fixing the armor.."); if (tech_roll(player, mech, 1) < 0) { mod = 3; if (fixarmor_fail(player,mech,loc,&change)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (3 * ochange * mod) / 2)), 0, loc, very_fake_func, (void *) (40 +4), (void *) ((mech) + player * (16*16*256)); return; }} else { if (fixarmor_succ(player,mech,loc,&change)<0) return; };


    muxevent_add(MAX(1, (tech_addtechtime(player, (3 * change * mod) / 2) - (change > 0 ? 60 * (3 * change * (change - 1) / (change)) : 0))), 0, (40 +4), event_mech_repairarmor, (void *) mech, (void *) (((change * 16 + loc)) + player * (16*16*256));

}

void tech_fixinternal (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c; int ochange;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, ((void *)0),((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    from = ((mech)->ud.sections[loc].internal);
    to = (mech)->ud.sections[loc].internal_orig;
    if (from == to) { mecha_notify(player,"The location doesn't need internals' repair!"); return; };
    change = to - from;
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That part's blown off! Use reattach first!"); return; };

    if (((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That location has been flooded! Use reseal first!"); return; };

    if (SomeoneFixing(mech, loc)) { mecha_notify(player,"Someone's repairing that section already!"); return; };

    if (SomeoneScrappingLoc(mech, loc)) { mecha_notify(player,"Someone's scrapping that section - no repairs are possible!"); return; };

    ochange = change;
    if (fixinternal_econ(player,mech,loc,&change)<0) return; mecha_notify(player,"You start fixing the internals.."); if (tech_roll(player, mech, 2) < 0) { mod = 3; if (fixinternal_fail(player,mech,loc,&change)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (9 * ochange * mod) / 2)), 0, loc, very_fake_func, (void *) (40 +4), (void *) ((mech) + player * (16*16*256)); return; }} else { if (fixinternal_succ(player,mech,loc,&change)<0) return; };



    muxevent_add(MAX(1, (tech_addtechtime(player, (9 * change * mod) / 2) - (change > 0 ? 60 * (9 * change * (change - 1) / (change)) : 0))), 0, (40 +5), event_mech_repairinternal, (void *) mech, (void *) (((change * 16 + loc)) + player * (16*16*256));

}





int Invalid_Repair_Path(MECH * mech, int loc)
{
    if ((mech)->ud.type != 0)
 return 0;
    switch (loc) {
 case 7:if ((!((mech)->ud.sections[4].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[4].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))))return 1;break;;
 case 2:if ((!((mech)->ud.sections[4].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[4].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))))return 1;break;;
 case 3:if ((!((mech)->ud.sections[4].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[4].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))))return 1;break;;
 case 0:if ((!((mech)->ud.sections[2].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[2].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))))return 1;break;;
 case 1:if ((!((mech)->ud.sections[3].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[3].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))))return 1;break;;
 case 5:if ((!((mech)->ud.sections[4].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[4].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))))return 1;break;;
 case 6:if ((!((mech)->ud.sections[4].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[4].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))))return 1;break;;
    }
    return 0;
}

int unit_is_fixable(MECH * mech)
{
    int i;

    for (i = 0; i < 8; i++) {
 if (!(mech)->ud.sections[i].internal_orig)
     continue;
 if (!(!((mech)->ud.sections[i].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[i].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))))
     continue;
 if ((mech)->ud.type == 0)
     if (i == 4)
  return 0;
 if ((mech)->ud.type == 2)
     if (i != 5)
  return 0;
 if ((mech)->ud.type == 1)
     if (i != 4)
  return 0;
    }
    return 1;
};

void tech_reattach (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, ((void *)0),((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if ((mech)->ud.type == 8) { mecha_notify(player,"You can't reattach a Battlesuit! Use 'replacesuit'!"); return; };

    if (!(!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That section isn't destroyed!"); return; };
    if (Invalid_Repair_Path(mech, loc)) { mecha_notify(player,"You need to reattach adjacent locations first!"); return; };

    if (SomeoneAttaching(mech, loc)) { mecha_notify(player,"Someone's attaching that section already!"); return; };

    if (!unit_is_fixable(mech)) { mecha_notify(player,"You see nothing to reattach it to (read:unit is cored)."); return; };

    if (reattach_econ(player,mech,loc)<0) return; mecha_notify(player,"You start replacing the section.."); if (tech_roll(player, mech, 3) < 0) { mod = 3; if (reattach_fail(player,mech,loc)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (240 * mod) / 2)), 0, (40 +2), very_fake_func, (void *) mech, (void *) ((loc) + player * (16*16*256));return; }} else { if (reattach_succ(player,mech,loc)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (240 * mod) / 2)), 0, (40 +2), event_mech_reattach, (void *) mech, (void *) ((loc) + player * (16*16*256));


}

void tech_replacesuit (dbref player, void * data, char * buffer)
{
    int wSuits = 0;

    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, ((void *)0),((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if ((mech)->ud.type != 8) { mecha_notify(player,"You can only use 'replacesuit' on a battlesuit unit!"); return; };


    wSuits = CountBSuitMembers(mech);

    if ((mech)->rd.maxsuits <= wSuits) { mecha_notify(player,tprintf ("This %s is already full! This %s only consists of %d suits!", GetLCaseBSuitName(mech), GetLCaseBSuitName(mech), (mech)->rd.maxsuits)); return; };




    if ((loc >= (mech)->rd.maxsuits) || (loc < 0)) { mecha_notify(player,tprintf("Invalid suit! This %s only consists of %d suits!", GetLCaseBSuitName(mech), (mech)->rd.maxsuits)); return; };




    if (!(!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That suit isn't destroyed!"); return; };

    if (SomeoneReplacingSuit(mech, loc)) { mecha_notify(player,"Someone's already rebuilding that suit!"); return; };

    if (wSuits <= 0) { mecha_notify(player,"You are unable to replace the suits here! None of the buggers are still alive!"); return; };

    if (replacesuit_econ(player,mech,loc)<0) return; mecha_notify(player,"You start replacing the missing suit."); if (tech_roll(player, mech, 3) < 0) { mod = 3; if (replacesuit_fail(player,mech,loc)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (120 * mod) / 2)), 0, (40 +14), very_fake_func, (void *) mech, (void *) ((loc) + player * (16*16*256));return; }} else { if (replacesuit_succ(player,mech,loc)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (120 * mod) / 2)), 0, (40 +14), event_mech_replacesuit, (void *) mech, (void *) ((loc) + player * (16*16*256));



}







void tech_reseal (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    switch (tech_parsepart(mech, buffer, &loc, ((void *)0),((void *)0))) { case -1: mecha_notify(player,"Invalid section!");return; case -2: mecha_notify(player,"Invalid part!");return; };
    if ((!((mech)->ud.sections[loc].armor) && (((((mech)->ud.type == 5) || (((((mech)->ud.type)==7 || ((mech)->ud.type)==4)))) || !((mech)->ud.sections[loc].internal)) && !((((mech)->ud.type)==7 || ((mech)->ud.type)==4))))) { mecha_notify(player,"That section is destroyed!"); return; };
    if (!((mech)->ud.sections[loc].config & 0x08)) { mecha_notify(player,"That has not been flooded!"); return; };
    if (Invalid_Repair_Path(mech, loc)) { mecha_notify(player,"You need to reattach adjacent locations first!"); return; };

    if (SomeoneResealing(mech, loc)) { mecha_notify(player,"Someone's sealing that section already!"); return; };

    if (reseal_econ(player,mech,loc)<0) return; mecha_notify(player,"You start resealing the section."); if (tech_roll(player, mech, 0) < 0) { mod = 3; if (reseal_fail(player,mech,loc)<0) { muxevent_add(MAX(1, tech_addtechtime(player, (60 * mod) / 2)), 0, (40 +13), very_fake_func, (void *) mech, (void *) ((loc) + player * (16*16*256));return; }} else { if (reseal_succ(player,mech,loc)<0) return; } muxevent_add(MAX(1, tech_addtechtime(player, (60 * mod) / 2)), 0, (40 +13), event_mech_reseal, (void *) mech, (void *) ((loc) + player * (16*16*256));


}

void tech_magic (dbref player, void * data, char * buffer)
{
    MECH *mech = (MECH *) data; int loc, part, t, full, now, from, to, change, mod=2, isds=0; char *c;;

    if (!((((db[player].powers2 & 0x00000040) != 0) || (((db[player].flags & 0x20000000) != 0) || ((db[player].flags & 0x00000010) || ((db[db[player].owner].flags & 0x00000010) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))))))) { mecha_notify(player,"Insufficient clearance to access the command."); return; }; if (!mech) { mecha_notify(player,"Error has occured in techcommand ; please contact a wiz"); return; }; isds = (((mech)->ud.type)==7 || ((mech)->ud.type)==4); if (muxevent_count_type_Data(3,(void *) mech) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's starting up! Please stop the sequence first."); return; }; if (((mech)->rd.status & 0x08) && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The mech's started up ; please shut it down first."); return; }; if (!isds && !(mech)->pd.stall && !(((db[db[player].owner].flags & 0x00000010) || ((db[db[db[player].owner].owner].flags & 0x00000010) && (((db[db[player].owner].flags & 0x02000000) != 0) || ((db[db[db[player].owner].owner].flags & 0x02000000) != 0) || ((db[player].owner) == db[db[player].owner].owner)))) && (((db[player].flags & 0x02000000) != 0) || ((db[db[player].owner].flags & 0x02000000) != 0) || ((player) == db[player].owner)))) { mecha_notify(player,"The 'mech isn't in a repair stall!"); return; };;
    mecha_notify(player,"Doing the magic..");
    do_magic(mech);
    mech_int_check(mech, 1);
    mecha_notify(player,"Done!");
}
